<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=360, height=640" />
  <title>Content Creation Tool with WebGL Warping</title>
  <!-- Import available Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Asap+Condensed&family=Damion&family=Sigmar+One&family=Lobster&family=Lato&family=Baskervville&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    .toolbar {
      width: 250px;
      background: #f0f0f0;
      padding: 10px;
      overflow-y: auto;
      border-right: 1px solid #ccc;
    }
    .toolbar h3 { margin-top: 20px; }
    .control-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; }
    #widgetControls {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      background: #fff;
      display: none;
    }
    #psychedelicControls {
      margin-top: 10px;
      display: none;
    }
    #psychedelicControls label { font-size: 0.9em; margin-top: 5px; }
    #glitchControls {
      margin-top: 10px;
      display: none;
    }
    #glitchControls label { font-size: 0.9em; margin-top: 5px; }
    #textWidgetControls {
      margin-top: 10px;
      display: none;
      padding: 10px;
      background: #f9f9f9;
      border-top: 1px solid #ddd;
    }
    #textWidgetControls h4 { margin-top: 0; margin-bottom: 10px; }
    #textWidgetControls .control-group { margin-bottom: 10px; }
    .editor {
      position: relative;
      width: 360px;
      height: 640px;
      background: #ddd;
    }
    #bgCanvas, #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 360px;
      height: 640px;
    }
    #bgCanvas { z-index: 0; }
    #overlayCanvas {
      z-index: 1;
      background: transparent;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <h3>Background Widget</h3>
    <div class="control-group">
      <label for="backgroundUpload">Upload Background</label>
      <input type="file" id="backgroundUpload" accept="image/*" />
    </div>
    <div class="control-group">
      <label>Effect Presets</label>
      <button onclick="applyBackgroundPreset('psychedelic')">Psychedelic</button>
      <button onclick="applyBackgroundPreset('classicGlass')">Classic Glass</button>
      <button onclick="applyBackgroundPreset('glitch')">Glitch</button>
      <button onclick="applyBackgroundPreset('lensFlare')">Lens Flare</button>
      <button onclick="applyBackgroundPreset('colorPass')">Color Pass</button>
      <button onclick="applyBackgroundPreset('classical')">Classical</button>
      <button onclick="applyBackgroundPreset('dreamscape')">Dreamscape</button>
      <button onclick="applyBackgroundPreset('waterRipple')">Water Ripple</button>
    </div>
    <hr />
    <h3>Text Widget</h3>
    <div class="control-group">
      <label for="textInput">Enter Text</label>
      <textarea id="textInput" placeholder="Your text here" rows="2" style="width: 100%;"></textarea>
    </div>
    <div class="control-group">
      <label for="fontSelect">Select Font</label>
      <select id="fontSelect">
        <option value="Asap Condensed">Asap Condensed</option>
        <option value="Agdasima">Agdasima (fallback to sans-serif)</option>
        <option value="Damion">Damion</option>
        <option value="Sigmar One">Sigmar</option>
        <option value="Lobster">Lobster</option>
        <option value="Lato">Lato</option>
        <option value="Baskervville">Baskervville</option>
        <option value="Agbalumo">Agbalumo (fallback to sans-serif)</option>
        <option value="Pixelify Sans">Pixelify Sans (fallback to sans-serif)</option>
      </select>
    </div>
    <div class="control-group">
      <label for="colorSelect">Select Color</label>
      <select id="colorSelect">
        <option value="#000000">#000000</option>
        <option value="#FFFFFF">#FFFFFF</option>
        <option value="#333333">#333333</option>
        <option value="#CCCCCC">#CCCCCC</option>
        <option value="#DC143C">#DC143C</option>
        <option value="#4169E1">#4169E1</option>
        <option value="#50C878">#50C878</option>
        <option value="#FFD700">#FFD700</option>
        <option value="#DA70D6">#DA70D6</option>
        <option value="#FFB6C1">#FFB6C1</option>
        <option value="#87CEEB">#87CEEB</option>
        <option value="#98FF98">#98FF98</option>
        <option value="#E6E6FA">#E6E6FA</option>
        <option value="#E2725B">#E2725B</option>
        <option value="#F5DEB3">#F5DEB3</option>
      </select>
    </div>
    <div class="control-group">
      <button onclick="addTextWidget()">Add Text</button>
    </div>
    <div class="control-group">
      <label>Text Effects Presets</label>
      <button onclick="applyTextEffectPreset('melting')">Melting</button>
      <button onclick="applyTextEffectPreset('psychedelic')">Psychedelic</button>
      <button onclick="applyTextEffectPreset('glitch')">Glitch</button>
      <button onclick="applyTextEffectPreset('glassRefraction')">Glass Refraction</button>
      <button onclick="applyTextEffectPreset('flyIn')">Fly In</button>
      <button onclick="applyTextEffectPreset('dvdLogo')">DVD Logo</button>
      <button onclick="applyTextEffectPreset('beatBounce')">Beat Bounce</button>
      <button onclick="applyTextEffectPreset('shadow')">Shadow</button>
      <button onclick="applyTextEffectPreset('metallic')">Metallic</button>
      <button onclick="applyTextEffectPreset('expandContract')">Expand/Contract</button>
      <button onclick="applyTextEffectPreset('dreamy')">Dreamy</button>
    </div>
    <hr />
    <h3>Stickers Widget</h3>
    <div class="control-group">
      <label for="stickerUpload">Upload Sticker</label>
      <input type="file" id="stickerUpload" accept="image/*" />
    </div>
    <div class="control-group">
      <button onclick="addStickerFromLibrary()">Add Default Sticker</button>
    </div>
    <div id="widgetControls">
      <h3>Widget Controls</h3>
      <button onclick="removeSelectedWidget()">Remove Widget</button>
      <div id="psychedelicControls">
        <label>
          Vignette Intensity: <span id="vignetteValue">0.5</span>
        </label>
        <input type="range" id="vignetteSlider" min="0" max="1" step="0.01" value="0.5">
        <label>
          Color Shift Offset: <span id="colorShiftValue">5</span>
        </label>
        <input type="range" id="colorShiftSlider" min="0" max="20" step="1" value="5">
        <label>
          Zoom Factor: <span id="zoomValue">1.2</span>
        </label>
        <!-- Wider zoom range: from 0.5 to 3.0 -->
        <input type="range" id="zoomSlider" min="0.5" max="3.0" step="0.01" value="1.2">
        <label>
          Red Channel Multiplier: <span id="redMultiplierValue">1.0</span>
        </label>
        <input type="range" id="redMultiplierSlider" min="0" max="2" step="0.1" value="1.0">
        <label>
          Green Channel Multiplier: <span id="greenMultiplierValue">0.6</span>
        </label>
        <input type="range" id="greenMultiplierSlider" min="0" max="2" step="0.1" value="0.6">
        <label>
          Blue Channel Multiplier: <span id="blueMultiplierValue">1.0</span>
        </label>
        <input type="range" id="blueMultiplierSlider" min="0" max="2" step="0.1" value="1.0">
        <label>
          Pulse Speed: <span id="pulseSpeedValue">0.0</span>
        </label>
        <input type="range" id="pulseSpeedSlider" min="0" max="5" step="0.1" value="0.0">
        <label>
          Rotation Speed: <span id="rotationSpeedValue">0.0</span>
        </label>
        <input type="range" id="rotationSpeedSlider" min="0" max="10" step="0.1" value="0.0">
        <label>
          Color Balance: <span id="colorBalanceValue">0.4</span>
        </label>
        <input type="range" id="colorBalanceSlider" min="0" max="1" step="0.01" value="0.4">
      </div>
      <div id="glitchControls">
        <label>
          Pixel Size: <span id="pixelSizeValue">4.0</span>
        </label>
        <input type="range" id="pixelSizeSlider" min="1" max="200" step="1" value="4.0">
        <label>
          Jitter Intensity: <span id="jitterIntensityValue">0.03</span>
        </label>
        <input type="range" id="jitterIntensitySlider" min="0" max="0.1" step="0.01" value="0.03">
        <label>
          Jitter Speed: <span id="jitterSpeedValue">2.0</span>
        </label>
        <input type="range" id="jitterSpeedSlider" min="0" max="5" step="0.1" value="2.0">
        <label>
          Compression Strength: <span id="compressionStrengthValue">0.8</span>
        </label>
        <input type="range" id="compressionStrengthSlider" min="0" max="1" step="0.1" value="0.8">
        <label>
          RGB Shift Amount: <span id="rgbShiftAmountValue">2.0</span>
        </label>
        <input type="range" id="rgbShiftAmountSlider" min="0" max="5" step="0.1" value="2.0">
        <label>
          Glitch Interval: <span id="glitchIntervalValue">0.2</span>
        </label>
        <input type="range" id="glitchIntervalSlider" min="0" max="1" step="0.1" value="0.2">
        <label>
          Glitch Amount: <span id="glitchAmountValue">0.5</span>
        </label>
        <input type="range" id="glitchAmountSlider" min="0" max="1" step="0.1" value="0.5">
        <label>
          Gradient Effect: <span id="purpleTintValue">0.4</span>
        </label>
        <input type="range" id="purpleTintSlider" min="0" max="1" step="0.1" value="0.4">
        <label>
          ASCII Effect: <span id="asciiEffectValue">0.0</span>
        </label>
        <input type="range" id="asciiEffectSlider" min="0" max="1" step="0.1" value="0.0">
        <label>
          ASCII Density: <span id="asciiDensityValue">1.0</span>
        </label>
        <input type="range" id="asciiDensitySlider" min="0.5" max="3" step="0.1" value="1.0">
      </div>
      <div id="lensFlareControls">
        <label>
          Flare Intensity: <span id="flareIntensityValue">1.7</span>
        </label>
        <input type="range" id="flareIntensitySlider" min="0" max="2" step="0.1" value="1.7">
        <label>
          Flare Position X: <span id="flarePosXValue">1.05</span>
        </label>
        <input type="range" id="flarePosXSlider" min="-0.5" max="1.5" step="0.01" value="1.05">
        <label>
          Flare Position Y: <span id="flarePosYValue">-0.15</span>
        </label>
        <input type="range" id="flarePosYSlider" min="-0.5" max="1.5" step="0.01" value="-0.15">
        <label>
          Flare Scale: <span id="flareScaleValue">3.0</span>
        </label>
        <input type="range" id="flareScaleSlider" min="0.2" max="3.0" step="0.1" value="3.0">
        <label>
          Position Wiggle: <span id="positionWiggleValue">0.01</span>
        </label>
        <input type="range" id="positionWiggleSlider" min="0" max="0.1" step="0.01" value="0.01">
        <label>
          Rainbow Intensity: <span id="rainbowIntensityValue">1.0</span>
        </label>
        <input type="range" id="rainbowIntensitySlider" min="0" max="1" step="0.1" value="1.0">
        <label>
          Animation Speed: <span id="flareSpeedValue">2.0</span>
        </label>
        <input type="range" id="flareSpeedSlider" min="0" max="2" step="0.1" value="2.0">
        <label>
          Glow Size: <span id="glareSizeValue">0.7</span>
        </label>
        <input type="range" id="glareSizeSlider" min="0.1" max="1" step="0.1" value="0.7">
        <label>
          Ray Count: <span id="rayCountValue">48</span>
        </label>
        <input type="range" id="rayCountSlider" min="8" max="48" step="4" value="48">
        <label>
          Vignette Intensity: <span id="vignetteIntensityValue">0.5</span>
        </label>
        <input type="range" id="vignetteIntensitySlider" min="0" max="1" step="0.1" value="0.5">
        <label>
          Noise Intensity: <span id="noiseIntensityValue">0.1</span>
        </label>
        <input type="range" id="noiseIntensitySlider" min="0" max="0.3" step="0.01" value="0.1">
        <label>
          Zoom Effect: <span id="zoomEffectValue">1.0</span>
        </label>
        <input type="range" id="zoomEffectSlider" min="0" max="1" step="0.1" value="1.0">
        <label>
          Zoom Speed: <span id="zoomSpeedValue">1.0</span>
        </label>
        <input type="range" id="zoomSpeedSlider" min="0.1" max="3" step="0.1" value="1.0">
      </div>
      <div id="textWidgetControls">
        <h4>Text Properties</h4>
        <div class="control-group">
          <label for="editTextInput">Edit Text</label>
          <textarea id="editTextInput" placeholder="Your text here" rows="2" style="width: 100%;"></textarea>
        </div>
        <div class="control-group">
          <label for="editFontSelect">Change Font</label>
          <select id="editFontSelect">
            <option value="Asap Condensed">Asap Condensed</option>
            <option value="Agdasima">Agdasima (fallback to sans-serif)</option>
            <option value="Damion">Damion</option>
            <option value="Sigmar One">Sigmar</option>
            <option value="Lobster">Lobster</option>
            <option value="Lato">Lato</option>
            <option value="Baskervville">Baskervville</option>
            <option value="Agbalumo">Agbalumo (fallback to sans-serif)</option>
            <option value="Pixelify Sans">Pixelify Sans (fallback to sans-serif)</option>
          </select>
        </div>
        <div class="control-group">
          <label for="editColorSelect">Change Color</label>
          <select id="editColorSelect">
            <option value="#000000">#000000</option>
            <option value="#FFFFFF">#FFFFFF</option>
            <option value="#333333">#333333</option>
            <option value="#CCCCCC">#CCCCCC</option>
            <option value="#DC143C">#DC143C</option>
            <option value="#4169E1">#4169E1</option>
            <option value="#50C878">#50C878</option>
            <option value="#FFD700">#FFD700</option>
            <option value="#DA70D6">#DA70D6</option>
            <option value="#FFB6C1">#FFB6C1</option>
            <option value="#87CEEB">#87CEEB</option>
            <option value="#98FF98">#98FF98</option>
            <option value="#E6E6FA">#E6E6FA</option>
            <option value="#E2725B">#E2725B</option>
            <option value="#F5DEB3">#F5DEB3</option>
          </select>
        </div>
        <div class="control-group">
          <label>
            Rotation: <span id="textRotationValue">0</span>Â°
          </label>
          <input type="range" id="textRotationSlider" min="0" max="360" step="1" value="0">
        </div>
        <button onclick="updateSelectedTextWidget()">Apply Changes</button>
      </div>
    </div>
  </div>
  <div class="editor">
    <canvas id="bgCanvas" width="360" height="640"></canvas>
    <canvas id="overlayCanvas" width="360" height="640"></canvas>
  </div>
  <script>
    /***** Global Variables *****/
    let backgroundWidget = null;
    const widgets = []; // for text and sticker widgets
    let selectedWidget = null;
    let isDragging = false;
    let isScaling = false;
    let dragOffset = { x: 0, y: 0 };
    let initialScale = 1;
    let initialMouseDist = 0;
    const psychedelicParams = {
      vignette: 0.5,
      colorShift: 5,
      zoom: 1.2,
      redMultiplier: 1.0,
      greenMultiplier: 0.6,
      blueMultiplier: 1.0,
      pulseSpeed: 0.0,
      rotationSpeed: 0.0,
      colorBalance: 0.4
    };
    const glitchParams = {
      pixelSize: 4.0,
      jitterIntensity: 0.03,
      jitterSpeed: 2.0,
      compressionStrength: 0.8,
      rgbShiftAmount: 2.0,
      glitchInterval: 0.2,
      glitchAmount: 0.5,
      gradientIntensity: 0.4,
      asciiEffect: 0.0,
      asciiDensity: 1.0
    };
    const lensFlareParams = {
      flareIntensity: 1.7,
      flarePosition: [1.05, -0.15],
      rainbowIntensity: 1.0,
      flareSpeed: 2.0,
      glareSize: 0.7,
      rayCount: 48,
      flareScale: 3.0,
      positionWiggle: 0.01,
      vignetteIntensity: 0.5,
      noiseIntensity: 0.1,
      zoomEffect: 1.0,
      zoomSpeed: 1.0
    };

    /***** WebGL Setup *****/
    const bgCanvas = document.getElementById("bgCanvas");
    const gl = bgCanvas.getContext("webgl");
    if (!gl) { alert("WebGL not supported!"); }
    
    // Vertex shader is shared between all effects
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main(){
        gl_Position = vec4(a_position, 0, 1);
        v_texCoord = a_texCoord;
      }
    `;
    
    // Psychedelic shader
    const fragmentShaderSource = `
      precision mediump float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_zoom;
      uniform float u_vignette;
      uniform float u_colorShift;
      uniform float u_redMultiplier;
      uniform float u_greenMultiplier;
      uniform float u_blueMultiplier;
      uniform float u_pulseSpeed;
      uniform float u_rotationSpeed;
      uniform float u_colorBalance;
      uniform float u_time;
      varying vec2 v_texCoord;
      
      // Base warp function.
      vec2 warpUV(vec2 uv, float zoom) {
        vec2 offset = uv - 0.5;
        float r = length(offset);
        float factor = mix(1.0, zoom, smoothstep(0.0, 1.0, r));
        return 0.5 + offset * factor;
      }
      
      // Warp function for offset channels with extra distortion.
      vec2 warpChannel(vec2 uv, float zoom, float extraWarp) {
        vec2 offset = uv - 0.5;
        float r = length(offset);
        float factor = mix(1.0, zoom * (1.0 + extraWarp * smoothstep(0.0, 1.0, r)), smoothstep(0.0, 1.0, r));
        return 0.5 + offset * factor;
      }
      
      // Rotation function
      vec2 rotate(vec2 uv, float angle) {
        float s = sin(angle);
        float c = cos(angle);
        mat2 rotMat = mat2(c, -s, s, c);
        return (uv - 0.5) * rotMat + 0.5;
      }
      
      void main(){
        vec2 center = vec2(0.5, 0.5);
        
        // Apply time-based effects if enabled
        float pulseEffect = 1.0;
        if (u_pulseSpeed > 0.0) {
          pulseEffect = 1.0 + 0.2 * sin(u_time * u_pulseSpeed);
        }
        
        float rotationAngle = 0.0;
        if (u_rotationSpeed > 0.0) {
          // Create oscillating rotation that changes direction
          // Using sin to oscillate between -1 and 1, multiplied by PI to get half rotations
          rotationAngle = sin(u_time * u_rotationSpeed * 0.05) * 3.14159;
        }
        
        // Apply rotation if enabled
        vec2 rotatedCoord = rotate(v_texCoord, rotationAngle);
        
        // Base warped UV with pulse effect
        vec2 baseUV = warpUV(rotatedCoord, u_zoom * pulseEffect);
        vec4 baseColor = texture2D(u_image, baseUV);
        
        // Radial vector from center.
        vec2 delta = rotatedCoord - center;
        float r = length(delta);
        vec2 radial = (r < 0.0001) ? vec2(0.0) : normalize(delta);
        
        // Progressive shift amount.
        float shiftAmount = u_colorShift / u_resolution.x * smoothstep(0.0, 1.0, r);
        
        // Apply different multipliers for each channel.
        vec2 redUV = warpChannel(rotatedCoord + radial * shiftAmount * u_redMultiplier, u_zoom * pulseEffect, 0.7);
        vec2 greenUV = warpChannel(rotatedCoord + radial * shiftAmount * u_greenMultiplier, u_zoom * pulseEffect, 0.4);
        vec2 blueUV = warpChannel(rotatedCoord - radial * shiftAmount * u_blueMultiplier, u_zoom * pulseEffect, 1.0);
        
        // Sample and tint each channel.
        vec4 redSample = texture2D(u_image, redUV);
        redSample = vec4(redSample.r, 0.0, 0.0, 1.0);
        
        vec4 greenSample = texture2D(u_image, greenUV);
        greenSample = vec4(0.0, greenSample.g, 0.0, 1.0);
        
        vec4 blueSample = texture2D(u_image, blueUV);
        blueSample = vec4(0.0, 0.0, blueSample.b, 1.0);
        
        // Blend the base with the pure tinted channels.
        vec4 color = baseColor * (1.0 - u_colorBalance) + (redSample + greenSample + blueSample) * u_colorBalance;
        
        // Apply vignette based on distance from center.
        float dist = distance(v_texCoord, center);
        float vig = smoothstep(0.6, 1.0, dist);
        color.rgb *= mix(1.0, 1.0 - u_vignette, vig);
        
        gl_FragColor = color;
      }
    `;
    
    // Glitch shader
    const glitchShaderSource = `
      precision mediump float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_pixelSize;
      uniform float u_jitterIntensity;
      uniform float u_jitterSpeed;
      uniform float u_compressionStrength;
      uniform float u_rgbShiftAmount;
      uniform float u_glitchInterval;
      uniform float u_glitchAmount;
      uniform float u_gradientIntensity;
      uniform float u_asciiEffect;
      uniform float u_asciiDensity;
      varying vec2 v_texCoord;
      
      // Random function
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      // 2D Noise based on Morgan McGuire's implementation
      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        
        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        
        // Smooth interpolation
        vec2 u = f * f * (3.0 - 2.0 * f); // Cubic Hermite curve
        
        // Mix 4 corners
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }
      
      // Block function for pixelation
      vec2 pixelate(vec2 uv, float pixelSize) {
        return floor(uv * pixelSize) / pixelSize;
      }
      
      // Scanline jitter function
      vec2 scanlineJitter(vec2 uv, float time, float intensity) {
        float y = floor(uv.y * u_resolution.y);
        float jitterOffset = random(vec2(y, time)) * 2.0 - 1.0;
        
        // Apply horizontal jitter to rows based on time
        float jitterThreshold = sin(time * u_jitterSpeed) * 0.5 + 0.5;
        float jitterAmount = step(jitterThreshold, random(vec2(y, floor(time * 20.0)))) * intensity;
        
        return vec2(uv.x + jitterAmount * jitterOffset, uv.y);
      }
      
      // RGB shift function
      vec4 rgbShift(sampler2D tex, vec2 uv, float amount) {
        float r = texture2D(tex, uv + vec2(amount, 0.0) / u_resolution).r;
        float g = texture2D(tex, uv).g;
        float b = texture2D(tex, uv - vec2(amount, 0.0) / u_resolution).b;
        return vec4(r, g, b, 1.0);
      }
      
      // Compression artifacts simulation
      vec4 compressionArtifacts(sampler2D tex, vec2 uv, float strength) {
        // Create blocky artifacts by quantizing the UV coordinates
        vec2 blockSize = vec2(8.0, 8.0) * strength;
        vec2 blockUV = floor(uv * u_resolution / blockSize) * blockSize / u_resolution;
        
        // Sample the texture with the quantized coordinates
        vec4 blockColor = texture2D(tex, blockUV);
        
        // Add some noise to simulate compression noise
        float noiseAmount = strength * 0.1;
        float noiseValue = (random(uv + vec2(u_time * 0.01)) * 2.0 - 1.0) * noiseAmount;
        
        // Mix the original color with the blocky color based on strength
        vec4 originalColor = texture2D(tex, uv);
        vec4 result = mix(originalColor, blockColor, strength * 0.7);
        
        // Add the noise
        result.rgb += vec3(noiseValue);
        
        return result;
      }
      
      // Apply gradient map to a color based on its luminance
      vec3 applyGradientMap(vec3 color) {
        // Calculate luminance (brightness)
        float luminance = dot(color, vec3(0.299, 0.587, 0.114));
        
        // Define gradient colors (dark purple to bright cyan)
        vec3 darkColor = vec3(0.3, 0.0, 0.5);   // Dark purple
        vec3 midColor = vec3(0.8, 0.2, 0.8);    // Bright purple/pink
        vec3 brightColor = vec3(0.0, 0.8, 1.0); // Cyan
        
        // Map luminance to gradient
        vec3 gradientColor;
        if (luminance < 0.5) {
          // Map dark to mid range (0.0-0.5)
          gradientColor = mix(darkColor, midColor, luminance * 2.0);
        } else {
          // Map mid to bright range (0.5-1.0)
          gradientColor = mix(midColor, brightColor, (luminance - 0.5) * 2.0);
        }
        
        return gradientColor;
      }
      
      // ASCII art effect
      vec3 applyAsciiEffect(sampler2D tex, vec2 uv, float density) {
        // Calculate cell size based on density
        float cellSize = 8.0 / density;
        
        // Pixelate the UV coordinates to create a grid
        vec2 asciiUV = floor(uv * u_resolution / cellSize) * cellSize / u_resolution;
        
        // Sample the texture at the cell center
        vec4 cellColor = texture2D(tex, asciiUV + (0.5 * cellSize / u_resolution));
        
        // Calculate brightness
        float brightness = dot(cellColor.rgb, vec3(0.299, 0.587, 0.114));
        
        // Define ASCII patterns based on brightness
        // We'll simulate ASCII by using different brightness levels
        float pattern;
        
        // Create a 2x2 dither pattern within each cell
        vec2 patternUV = fract(uv * u_resolution / (cellSize * 0.5));
        
        if (brightness < 0.2) {
          // Very dark: sparse pattern (.)
          pattern = (patternUV.x < 0.5 && patternUV.y < 0.5) ? 0.1 : 0.0;
        } else if (brightness < 0.4) {
          // Dark: slightly denser pattern (:)
          pattern = (patternUV.x < 0.5 || patternUV.y < 0.5) ? 0.3 : 0.0;
        } else if (brightness < 0.6) {
          // Medium: medium density pattern (%)
          pattern = (patternUV.x < 0.5) != (patternUV.y < 0.5) ? 0.5 : 0.2;
        } else if (brightness < 0.8) {
          // Bright: dense pattern (#)
          pattern = (patternUV.x > 0.5 || patternUV.y > 0.5) ? 0.7 : 0.5;
        } else {
          // Very bright: full pattern (@)
          pattern = (patternUV.x > 0.5 && patternUV.y > 0.5) ? 1.0 : 0.8;
        }
        
        // Add some variation based on position to create more visual interest
        float variation = random(floor(uv * u_resolution / cellSize)) * 0.2 - 0.1;
        
        // Create the final ASCII effect
        vec3 asciiColor = vec3(pattern + variation);
        
        // Tint the ASCII with the original color
        asciiColor *= normalize(cellColor.rgb + 0.1);
        
        return asciiColor;
      }
      
      void main() {
        vec2 uv = v_texCoord;
        
        // Random glitch timing
        float glitchTime = floor(u_time / u_glitchInterval);
        float glitchFactor = random(vec2(glitchTime, 2345.67));
        float glitchActive = step(1.0 - u_glitchAmount, glitchFactor);
        
        // Apply pixelation
        vec2 pixelatedUV = mix(uv, pixelate(uv, u_pixelSize), glitchActive);
        
        // Apply scanline jitter
        vec2 jitteredUV = scanlineJitter(pixelatedUV, u_time, u_jitterIntensity * glitchActive);
        
        // Apply compression artifacts
        vec4 compressedColor = compressionArtifacts(u_image, jitteredUV, u_compressionStrength * glitchActive);
        
        // Apply RGB shift
        vec4 shiftedColor = rgbShift(u_image, jitteredUV, u_rgbShiftAmount * glitchActive);
        
        // Mix compression artifacts and RGB shift
        vec4 finalColor = mix(compressedColor, shiftedColor, 0.5);
        
        // Add occasional vertical color bars
        if (glitchActive > 0.5 && random(vec2(floor(uv.x * 10.0), glitchTime)) > 0.95) {
          float barIntensity = random(vec2(floor(uv.x * 10.0), glitchTime + 1.0));
          finalColor.rgb = mix(finalColor.rgb, vec3(barIntensity, barIntensity * 0.5, barIntensity * 0.2), 0.3);
        }
        
        // Add occasional horizontal glitch lines
        if (glitchActive > 0.5 && random(vec2(floor(uv.y * 20.0), glitchTime)) > 0.97) {
          finalColor.rgb = mix(finalColor.rgb, vec3(1.0, 1.0, 1.0), 0.2);
        }
        
        // Apply gradient map
        vec3 gradientMapped = applyGradientMap(finalColor.rgb);
        finalColor.rgb = mix(finalColor.rgb, gradientMapped, u_gradientIntensity);
        
        // Apply ASCII effect
        if (u_asciiEffect > 0.0) {
          vec3 asciiColor = applyAsciiEffect(u_image, jitteredUV, u_asciiDensity);
          finalColor.rgb = mix(finalColor.rgb, asciiColor, u_asciiEffect);
        }
        
        gl_FragColor = finalColor;
      }
    `;
    
    // Lens Flare shader
    const lensFlareShaderSource = `
      precision mediump float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_flareIntensity;
      uniform vec2 u_flarePosition;
      uniform float u_rainbowIntensity;
      uniform float u_flareSpeed;
      uniform float u_glareSize;
      uniform float u_rayCount;
      uniform float u_flareScale;
      uniform float u_positionWiggle;
      uniform float u_vignetteIntensity;
      uniform float u_noiseIntensity;
      uniform float u_zoomEffect;
      uniform float u_zoomSpeed;
      varying vec2 v_texCoord;
      
      // Random and noise functions
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      // Improved noise function (Procedural)
      float noise(float t) {
        return random(vec2(t, t * 0.5 + u_time * 0.1));
      }
      
      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        
        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        
        // Smooth interpolation
        vec2 u = f * f * (3.0 - 2.0 * f); // Cubic Hermite curve
        
        // Mix 4 corners
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }
      
      // Function to get a rainbow color based on angle
      vec3 getRainbowColor(float angle, float time) {
        // Normalize angle to 0-1 range
        float normAngle = mod(angle / (2.0 * 3.14159), 1.0);
        
        // Add completely random variation to the color without any pattern
        float variation = noise(vec2(normAngle * 10.0 + time * 0.3, time * 0.5 + normAngle * 5.0)) * 0.15;
        normAngle = mod(normAngle + variation, 1.0);
        
        // Create rainbow colors
        vec3 color;
        if (normAngle < 0.167) {
          // Red to yellow
          color = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), normAngle * 6.0);
        } else if (normAngle < 0.333) {
          // Yellow to green
          color = mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), (normAngle - 0.167) * 6.0);
        } else if (normAngle < 0.5) {
          // Green to cyan
          color = mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 1.0), (normAngle - 0.333) * 6.0);
        } else if (normAngle < 0.667) {
          // Cyan to blue
          color = mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), (normAngle - 0.5) * 6.0);
        } else if (normAngle < 0.833) {
          // Blue to magenta
          color = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 1.0), (normAngle - 0.667) * 6.0);
        } else {
          // Magenta to red
          color = mix(vec3(1.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), (normAngle - 0.833) * 6.0);
        }
        
        // Add random color variation
        color += vec3(
          noise(vec2(normAngle * 20.0, time * 0.7)) * 0.2 - 0.1,
          noise(vec2(normAngle * 15.0, time * 0.6 + 10.0)) * 0.2 - 0.1,
          noise(vec2(normAngle * 25.0, time * 0.8 + 20.0)) * 0.2 - 0.1
        );
        
        return clamp(color, 0.0, 1.0);
      }
      
      // Function to get a tricolor tint based on brightness
      vec3 getTricolorTint(float brightness, float time) {
        // Add some subtle variation to the brightness
        float variation = noise(vec2(brightness * 5.0 + time * 0.2, time * 0.3)) * 0.1;
        brightness = clamp(brightness + variation, 0.0, 1.0);
        
        // Create tricolor tint: red for bright areas, blue for mid-tones, green for dark areas
        vec3 color;
        
        if (brightness > 0.66) {
          // Bright areas: transition from blue to red (0.66-1.0)
          color = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), (brightness - 0.66) * 3.0);
        } else if (brightness > 0.33) {
          // Mid-tones: transition from green to blue (0.33-0.66)
          color = mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), (brightness - 0.33) * 3.0);
        } else {
          // Dark areas: transition from black to green (0.0-0.33)
          color = mix(vec3(0.0, 0.3, 0.0), vec3(0.0, 1.0, 0.0), brightness * 3.0);
        }
        
        // Add subtle random color variation
        color += vec3(
          noise(vec2(brightness * 10.0, time * 0.5)) * 0.1 - 0.05,
          noise(vec2(brightness * 8.0, time * 0.4 + 10.0)) * 0.1 - 0.05,
          noise(vec2(brightness * 12.0, time * 0.6 + 20.0)) * 0.1 - 0.05
        );
        
        return clamp(color, 0.0, 1.0);
      }
      
      // Apply vignette effect with true Gaussian blur (no darkening)
      vec3 applyVignette(vec3 color, vec2 uv, float intensity) {
        float dist = distance(uv, vec2(0.5, 0.5));
        
        // Calculate blur amount based on distance from center - increased blur effect
        float blurAmount = smoothstep(0.2, 0.6, dist * intensity * 2.2);
        
        // Only apply blur in the vignette area to save performance
        if (blurAmount > 0.01) {
          // Implement a true Gaussian blur by sampling neighboring pixels
          vec3 blurredColor = vec3(0.0);
          float totalWeight = 0.0;
          
          // Increased blur radius based on distance from center
          float radius = 0.03 * blurAmount;
          
          // Sample in a 7x7 grid around the current pixel for stronger blur
          for (int x = -3; x <= 3; x++) {
            for (int y = -3; y <= 3; y++) {
              vec2 offset = vec2(float(x), float(y)) * radius;
              
              // Gaussian weight based on distance from center sample
              float weight = exp(-dot(offset, offset) * 3.0);
              
              // Sample the texture at the offset position
              vec3 sampleColor = texture2D(u_image, uv + offset).rgb;
              
              // Accumulate weighted sample
              blurredColor += sampleColor * weight;
              totalWeight += weight;
            }
          }
          
          // Normalize by total weight
          blurredColor /= totalWeight;
          
          // Blend between original and blurred color based on distance
          // Increased blend factor for stronger blur effect
          color = mix(color, blurredColor, blurAmount * 0.95);
        }
        
        // Return color without darkening
        return color;
      }
      
      // Apply film grain noise that looks more like traditional film grain
      vec3 applyNoise(vec3 color, vec2 uv, float time, float intensity) {
        // Constants for film grain simulation
        const float PI = 3.14159265359;
        
        // Calculate luminance - film grain is more visible in darker areas
        float luminance = dot(color, vec3(0.299, 0.587, 0.114));
        float grainMask = 5.0 - luminance * 0.5; // Moderate effect in shadows
        
        // Create truly random noise without any large-scale patterns
        // Use high-frequency noise with prime number multipliers to avoid patterns
        float n = 0.0;
        
        // Create multiple independent noise samples at different frequencies
        // Using prime numbers and irrational offsets to avoid creating patterns
        // Frequencies reduced by ~33% to increase grain size by 50%
        n += random(uv * 569.0 + vec2(time * 0.13, 0.0)) * 0.25;         // Was 853.0
        n += random(uv * 277.0 + vec2(0.0, time * 0.17)) * 0.25;         // Was 419.0
        n += random(uv * 661.0 + vec2(time * 0.19, time * 0.23)) * 0.25; // Was 997.0
        n += random(uv * 421.0 + vec2(time * 0.11, time * 0.13)) * 0.25; // Was 631.0
        
        // Add pixel-level variation to break up any potential patterns
        // Using golden ratio (1.61803) and other irrational numbers as offsets
        // Reduced frequency for larger grain
        vec2 pixelNoise = vec2(
            fract(sin(uv.x * 29172.3635 + time * 0.11) * 12345.6789),
            fract(sin(uv.y * 48771.5262 + time * 0.13) * 45678.9012)
        );
        n = mix(n, random(pixelNoise * 823.0 + time * 0.17), 0.3); // Was 1234.5
        
        // Scale the noise to the desired intensity
        float grainIntensity = intensity * 0.15;
        float grain = (n * 2.0 - 1.0) * grainIntensity * grainMask;
        
        // Apply the grain using multiply blend mode for darker grain effect
        // Multiply: base * blend
        vec3 grainColor = vec3(1.0 + grain);
        
        // Ensure we don't get values above 1.0 which would lighten the image
        grainColor = clamp(grainColor, 0.0, 1.0);
        
        // Apply multiply blend mode
        return color * grainColor;
      }
      
      // Enhanced lens flare function with vibrant RGB colors and varied rays
      vec3 lensFlare(vec2 uv, vec2 pos, float intensity, float scale) {
        // Apply scaling to the UV coordinates relative to the flare position
        uv = (uv - pos) / scale + pos;
        
        // Normalize coordinates to center
        vec2 main = uv - pos;
        vec2 uvd = uv * (length(uv));
        
        float dist = length(main);
        float ang = atan(main.y, main.x);
        
        // Time-based animation for noise patterns with multiple frequencies
        float timeNoise = u_time * u_flareSpeed;
        
        // Add some noise variation based on angle and distance with animation
        // Use multiple noise frequencies for more organic variation
        float n = noise(vec2(ang * 16.0 + timeNoise * 0.1, dist * 32.0 + timeNoise * 0.2)) * 0.5 +
                  noise(vec2(ang * 8.0 + timeNoise * 0.3, dist * 16.0 + timeNoise * 0.4)) * 0.3 +
                  noise(vec2(ang * 32.0 + timeNoise * 0.5, dist * 64.0 + timeNoise * 0.6)) * 0.2;
        
        // Main glow with noise variation
        float f0 = 1.0 / (length(uv - pos) * 16.0 / u_glareSize + 1.0);
        f0 = f0 + f0 * (sin(noise(vec2(sin(ang * 2.0) * 4.0 + timeNoise * 0.3, cos(ang * 3.0) * 5.0 + timeNoise * 0.4)) * 16.0) * 0.1 + dist * 0.1 + 0.8);
        
        // Various lens artifacts with RGB color separation
        float f1 = max(0.01 - pow(length(uv + 1.2 * pos), 1.9), 0.0) * 7.0;
        
        float f2 = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.8 * pos), 2.0)), 0.0) * 0.25;
        float f22 = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.85 * pos), 2.0)), 0.0) * 0.23;
        float f23 = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.9 * pos), 2.0)), 0.0) * 0.21;
        
        vec2 uvx = mix(uv, uvd, -0.5);
        
        float f4 = max(0.01 - pow(length(uvx + 0.4 * pos), 2.4), 0.0) * 6.0;
        float f42 = max(0.01 - pow(length(uvx + 0.45 * pos), 2.4), 0.0) * 5.0;
        float f43 = max(0.01 - pow(length(uvx + 0.5 * pos), 2.4), 0.0) * 3.0;
        
        uvx = mix(uv, uvd, -0.4);
        
        float f5 = max(0.01 - pow(length(uvx + 0.2 * pos), 5.5), 0.0) * 2.0;
        float f52 = max(0.01 - pow(length(uvx + 0.4 * pos), 5.5), 0.0) * 2.0;
        float f53 = max(0.01 - pow(length(uvx + 0.6 * pos), 5.5), 0.0) * 2.0;
        
        uvx = mix(uv, uvd, -0.5);
        
        float f6 = max(0.01 - pow(length(uvx - 0.3 * pos), 1.6), 0.0) * 6.0;
        float f62 = max(0.01 - pow(length(uvx - 0.325 * pos), 1.6), 0.0) * 3.0;
        float f63 = max(0.01 - pow(length(uvx - 0.35 * pos), 1.6), 0.0) * 5.0;
        
        // Create pure RGB color artifacts
        vec3 c = vec3(0.0);
        
        // Red channel artifacts
        c.r += f2 * 1.3 + f4 * 1.2 + f6 * 1.4;
        
        // Green channel artifacts
        c.g += f22 * 1.3 + f42 * 1.2 + f62 * 1.4;
        
        // Blue channel artifacts
        c.b += f23 * 1.3 + f43 * 1.2 + f63 * 1.4;
        
        // Add main glow with slight color tint
        c += vec3(f0 * 0.9, f0 * 1.0, f0 * 1.1);
        
        // Apply tricolor tint based on brightness if rainbow intensity is enabled
        if (u_rainbowIntensity > 0.0) {
          // Calculate the brightness of each pixel in the flare
          float brightness = dot(c, vec3(0.299, 0.587, 0.114));
          
          // Get tricolor tint based on brightness
          vec3 tintColor = getTricolorTint(brightness, u_time * u_flareSpeed * 0.1);
          
          // Apply the tint color using screen blend mode
          c = mix(c, 1.0 - (1.0 - c) * (1.0 - tintColor), u_rainbowIntensity);
        }
        
        // Add animated rainbow rays with more variation
        if (u_rainbowIntensity > 0.0) {
          float rayPhase = u_time * u_flareSpeed;
          float rayCount = u_rayCount;
          
          // Create evenly distributed rays
          for (float i = 0.0; i < 48.0; i++) {
            if (i >= rayCount) break;
            
            // Evenly distribute ray angles with slight random variation
            float rayAngle = 3.14159 * 2.0 * (i / rayCount);
            
            // Add completely random time-based variation to each ray angle
            float angleNoise = noise(vec2(i * 0.5, rayPhase * 0.2 + i * 0.3)) * 0.1;
            rayAngle += angleNoise;
            
            // Calculate angle difference for this ray
            float angleDiff = mod(abs(ang - rayAngle), 3.14159 * 2.0);
            angleDiff = min(angleDiff, 3.14159 * 2.0 - angleDiff);
            
            // Animated ray properties based on noise with multiple frequencies
            float rayTimeOffset = i * 0.1;
            
            // Animated ray length - varies over time with multiple noise frequencies
            float rayLength = 0.3 + 
                             noise(vec2(i * 0.3, rayPhase * 0.2 + rayTimeOffset)) * 0.3 +
                             noise(vec2(i * 0.7, rayPhase * 0.4 + rayTimeOffset + 10.0)) * 0.2 +
                             noise(vec2(i * 1.1, rayPhase * 0.6 + rayTimeOffset + 20.0)) * 0.2;
            
            // Animated ray width - varies over time with multiple noise frequencies
            float rayWidth = 0.05 + 
                            noise(vec2(i * 0.7, rayPhase * 0.3 + rayTimeOffset)) * 0.05 +
                            noise(vec2(i * 1.3, rayPhase * 0.5 + rayTimeOffset + 15.0)) * 0.05;
            
            // Animated ray opacity - complex pattern with multiple frequencies
            float rayOpacity = 0.3 + 
                              noise(vec2(i * 0.4, rayPhase * 0.5 + i * 0.2)) * 0.3 +
                              sin(rayPhase * 0.7 + i * 0.6) * 0.2 +
                              cos(rayPhase * 0.3 + i * 0.9) * 0.2;
            
            // Create thinner rays with more variation
            float ray = smoothstep(rayWidth, 0.0, angleDiff) * 
                        smoothstep(rayLength, rayLength * 0.5, dist) * 
                        rayOpacity * (1.0 + n * 0.3);
            
            // Get rainbow color with complex animation
            vec3 rayColor = getRainbowColor(rayAngle, rayPhase * 0.05 + i * 0.1);
            
            // Add the ray with rainbow coloring
            c += rayColor * ray * u_rainbowIntensity * 0.7;
            
            // Add secondary smaller rays between main rays for more detail
            if (i < rayCount - 1.0) {
              // Random offset between 0.3 and 0.7 of the way to the next ray
              float subRayOffset = 0.5 + noise(vec2(i * 0.9, rayPhase * 0.15)) * 0.4 - 0.2;
              float subRayAngle = rayAngle + 3.14159 * 2.0 * (subRayOffset / rayCount);
              
              // Add random variation to sub-ray angle
              subRayAngle += noise(vec2(i * 1.2, rayPhase * 0.25 + i * 0.4)) * 0.08;
              
              float subAngleDiff = mod(abs(ang - subRayAngle), 3.14159 * 2.0);
              subAngleDiff = min(subAngleDiff, 3.14159 * 2.0 - subAngleDiff);
              
              // Animated properties for secondary rays with complex patterns
              float subRayTimeOffset = i * 0.15 + 0.5;
              
              // Complex animation for sub-ray length
              float subRayLength = rayLength * (0.3 + 
                                  noise(vec2(i * 0.5, rayPhase * 0.25 + subRayTimeOffset)) * 0.2 +
                                  noise(vec2(i * 0.9, rayPhase * 0.35 + subRayTimeOffset + 5.0)) * 0.2);
              
              // Complex animation for sub-ray width
              float subRayWidth = rayWidth * (0.5 +
                                 noise(vec2(i * 0.8, rayPhase * 0.3 + subRayTimeOffset + 10.0)) * 0.3);
              
              // Complex animation for sub-ray opacity
              float subRayOpacity = rayOpacity * (0.3 + 
                                   noise(vec2(i * 0.6, rayPhase * 0.4 + subRayTimeOffset)) * 0.2 +
                                   sin(rayPhase * 0.9 + i * 0.7) * 0.2);
              
              float subRay = smoothstep(subRayWidth, 0.0, subAngleDiff) * 
                             smoothstep(subRayLength, subRayLength * 0.3, dist) * 
                             subRayOpacity * (1.0 + n * 0.2);
              
              // Different color for sub-rays with complex animation
              vec3 subRayColor = getRainbowColor(subRayAngle, rayPhase * 0.07 + i * 0.12 + dist * 0.5);
              
              c += subRayColor * subRay * u_rainbowIntensity * 0.4;
            }
          }
        }
        
        // Apply overall intensity
        return c * intensity * 1.5;
      }
      
      void main() {
        vec2 uv = v_texCoord * 2.0 - 1.0; // Convert to -1 to 1 range
        uv.x *= u_resolution.x / u_resolution.y; // Fix aspect ratio
        
        // Apply zoom effect to texture coordinates
        vec2 zoomedTexCoord = v_texCoord;
        if (u_zoomEffect > 0.0) {
          // Calculate zoom factor that oscillates between 1.0 and 1.1 (10% zoom)
          // Using a sine wave with adjustable speed
          float zoomFactor = 1.0 + 0.1 * u_zoomEffect * (sin(u_time * 0.1 * u_zoomSpeed) * 0.5 + 0.5);
          
          // Apply zoom from the center of the image
          zoomedTexCoord = (v_texCoord - 0.5) / zoomFactor + 0.5;
        }
        
        // Sample the original image with zoomed coordinates
        vec4 originalColor = texture2D(u_image, zoomedTexCoord);
        vec3 baseColor = originalColor.rgb;
        
        // Apply position wiggle if enabled
        vec2 wiggleOffset = vec2(0.0);
        if (u_positionWiggle > 0.0) {
          wiggleOffset.x = sin(u_time * 1.5) * u_positionWiggle;
          wiggleOffset.y = cos(u_time * 1.2) * u_positionWiggle;
        }
        
        // Apply vignette effect first if enabled
        if (u_vignetteIntensity > 0.0) {
          baseColor = applyVignette(baseColor, zoomedTexCoord, u_vignetteIntensity);
        }
        
        // Create lens flare with adjusted position and scale
        vec3 flare = lensFlare(uv, u_flarePosition * 2.0 - 1.0 + wiggleOffset, u_flareIntensity, u_flareScale);
        
        // Add subtle noise to reduce banding
        flare -= random(v_texCoord * u_resolution) * 0.015;
        
        // Apply proper screen blending mode: 1 - (1 - a) * (1 - b)
        vec3 result = 1.0 - (1.0 - baseColor) * (1.0 - flare);
        
        // Apply noise effect last
        if (u_noiseIntensity > 0.0) {
          result = applyNoise(result, zoomedTexCoord, u_time, u_noiseIntensity);
        }
        
        gl_FragColor = vec4(result, originalColor.a);
      }
    `;
    
    // Sunbeams shader
    
    function compileShader(gl, shaderSource, shaderType) {
      const shader = gl.createShader(shaderType);
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader compile failed: " + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    
    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link failed: " + gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }
    
    // Compile the vertex shader once
    const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    
    // Compile all fragment shaders
    const psychedelicFragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
    const glitchFragmentShader = compileShader(gl, glitchShaderSource, gl.FRAGMENT_SHADER);
    const lensFlareFragmentShader = compileShader(gl, lensFlareShaderSource, gl.FRAGMENT_SHADER);
    
    // Create shader programs
    const psychedelicProgram = createProgram(gl, vertexShader, psychedelicFragmentShader);
    const glitchProgram = createProgram(gl, vertexShader, glitchFragmentShader);
    const lensFlareProgram = createProgram(gl, vertexShader, lensFlareFragmentShader);
    
    // Current active program
    let activeProgram = psychedelicProgram;
    
    // Locations for psychedelic shader
    const psychedelicLocations = {
      a_position: gl.getAttribLocation(psychedelicProgram, "a_position"),
      a_texCoord: gl.getAttribLocation(psychedelicProgram, "a_texCoord"),
      u_resolution: gl.getUniformLocation(psychedelicProgram, "u_resolution"),
      u_zoom: gl.getUniformLocation(psychedelicProgram, "u_zoom"),
      u_vignette: gl.getUniformLocation(psychedelicProgram, "u_vignette"),
      u_colorShift: gl.getUniformLocation(psychedelicProgram, "u_colorShift"),
      u_redMultiplier: gl.getUniformLocation(psychedelicProgram, "u_redMultiplier"),
      u_greenMultiplier: gl.getUniformLocation(psychedelicProgram, "u_greenMultiplier"),
      u_blueMultiplier: gl.getUniformLocation(psychedelicProgram, "u_blueMultiplier"),
      u_pulseSpeed: gl.getUniformLocation(psychedelicProgram, "u_pulseSpeed"),
      u_rotationSpeed: gl.getUniformLocation(psychedelicProgram, "u_rotationSpeed"),
      u_colorBalance: gl.getUniformLocation(psychedelicProgram, "u_colorBalance"),
      u_time: gl.getUniformLocation(psychedelicProgram, "u_time")
    };
    
    // Locations for glitch shader
    const glitchLocations = {
      a_position: gl.getAttribLocation(glitchProgram, "a_position"),
      a_texCoord: gl.getAttribLocation(glitchProgram, "a_texCoord"),
      u_resolution: gl.getUniformLocation(glitchProgram, "u_resolution"),
      u_time: gl.getUniformLocation(glitchProgram, "u_time"),
      u_pixelSize: gl.getUniformLocation(glitchProgram, "u_pixelSize"),
      u_jitterIntensity: gl.getUniformLocation(glitchProgram, "u_jitterIntensity"),
      u_jitterSpeed: gl.getUniformLocation(glitchProgram, "u_jitterSpeed"),
      u_compressionStrength: gl.getUniformLocation(glitchProgram, "u_compressionStrength"),
      u_rgbShiftAmount: gl.getUniformLocation(glitchProgram, "u_rgbShiftAmount"),
      u_glitchInterval: gl.getUniformLocation(glitchProgram, "u_glitchInterval"),
      u_glitchAmount: gl.getUniformLocation(glitchProgram, "u_glitchAmount"),
      u_gradientIntensity: gl.getUniformLocation(glitchProgram, "u_gradientIntensity"),
      u_asciiEffect: gl.getUniformLocation(glitchProgram, "u_asciiEffect"),
      u_asciiDensity: gl.getUniformLocation(glitchProgram, "u_asciiDensity")
    };
    
    // Locations for lens flare shader
    const lensFlareLocations = {
      a_position: gl.getAttribLocation(lensFlareProgram, "a_position"),
      a_texCoord: gl.getAttribLocation(lensFlareProgram, "a_texCoord"),
      u_resolution: gl.getUniformLocation(lensFlareProgram, "u_resolution"),
      u_time: gl.getUniformLocation(lensFlareProgram, "u_time"),
      u_flareIntensity: gl.getUniformLocation(lensFlareProgram, "u_flareIntensity"),
      u_flarePosition: gl.getUniformLocation(lensFlareProgram, "u_flarePosition"),
      u_rainbowIntensity: gl.getUniformLocation(lensFlareProgram, "u_rainbowIntensity"),
      u_flareSpeed: gl.getUniformLocation(lensFlareProgram, "u_flareSpeed"),
      u_glareSize: gl.getUniformLocation(lensFlareProgram, "u_glareSize"),
      u_rayCount: gl.getUniformLocation(lensFlareProgram, "u_rayCount"),
      u_flareScale: gl.getUniformLocation(lensFlareProgram, "u_flareScale"),
      u_positionWiggle: gl.getUniformLocation(lensFlareProgram, "u_positionWiggle"),
      u_vignetteIntensity: gl.getUniformLocation(lensFlareProgram, "u_vignetteIntensity"),
      u_noiseIntensity: gl.getUniformLocation(lensFlareProgram, "u_noiseIntensity"),
      u_zoomEffect: gl.getUniformLocation(lensFlareProgram, "u_zoomEffect"),
      u_zoomSpeed: gl.getUniformLocation(lensFlareProgram, "u_zoomSpeed")
    };
    
    // Create buffers
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = new Float32Array([
      -1, -1,  1, -1,  -1, 1,
      -1, 1,   1, -1,   1, 1
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    
    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    const texCoords = new Float32Array([
      0, 1,  1, 1,  0, 0,
      0, 0,  1, 1,  1, 0
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
    
    /***** Overlay Setup *****/
    const overlayCanvas = document.getElementById("overlayCanvas");
    const ctx2d = overlayCanvas.getContext("2d");
    
    /***** Helper Functions for Widgets *****/
    function getWidgetBounds(widget) {
      if (widget.type === "text") {
        ctx2d.font = "30px " + widget.font;
        const textWidth = ctx2d.measureText(widget.text).width;
        const textHeight = 30;
        return {
          x: widget.x - (textWidth * widget.scale) / 2,
          y: widget.y - (textHeight * widget.scale) / 2,
          width: textWidth * widget.scale,
          height: textHeight * widget.scale
        };
      } else if (widget.type === "sticker" || widget.type === "background") {
        if (widget.image && widget.image.complete) {
          const width = widget.image.width * widget.scale;
          const height = widget.image.height * widget.scale;
          return { x: widget.x - width/2, y: widget.y - height/2, width, height };
        }
        return { x: widget.x, y: widget.y, width: 0, height: 0 };
      }
    }
    function widgetContainsPoint(widget, x, y) {
      const b = getWidgetBounds(widget);
      return x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height;
    }
    function widgetScaleHandleContainsPoint(widget, x, y) {
      const b = getWidgetBounds(widget);
      const handleSize = 10;
      return (x >= b.x + b.width - handleSize && x <= b.x + b.width &&
              y >= b.y + b.height - handleSize && y <= b.y + b.height);
    }
    function updateWidgetControls() {
      const widgetControls = document.getElementById("widgetControls");
      const textWidgetControls = document.getElementById("textWidgetControls");
      const psychedelicControls = document.getElementById("psychedelicControls");
      const glitchControls = document.getElementById("glitchControls");
      const lensFlareControls = document.getElementById("lensFlareControls");
      
      // Hide all controls first
      widgetControls.style.display = "none";
      textWidgetControls.style.display = "none";
      psychedelicControls.style.display = "none";
      glitchControls.style.display = "none";
      lensFlareControls.style.display = "none";
      
      if (selectedWidget) {
        widgetControls.style.display = "block";
        
        // Update widget controls based on widget type
        if (selectedWidget.type === "text") {
          textWidgetControls.style.display = "block";
          document.getElementById("textColorPicker").value = selectedWidget.color;
          document.getElementById("textOpacitySlider").value = selectedWidget.opacity;
          document.getElementById("textOpacityValue").textContent = selectedWidget.opacity;
          document.getElementById("textScaleSlider").value = selectedWidget.scale;
          document.getElementById("textScaleValue").textContent = selectedWidget.scale;
          document.getElementById("textRotationSlider").value = selectedWidget.rotation;
          document.getElementById("textRotationValue").textContent = selectedWidget.rotation;
          document.getElementById("fontSelect").value = selectedWidget.font;
        } else if (selectedWidget.type === "background") {
          if (selectedWidget.effectPreset === "psychedelic") {
            psychedelicControls.style.display = "block";
          } else if (selectedWidget.effectPreset === "glitch") {
            glitchControls.style.display = "block";
          } else if (selectedWidget.effectPreset === "lensFlare") {
            lensFlareControls.style.display = "block";
          }
        }
      }
    }
    
    /***** Background Functions *****/
    function applyBackgroundPreset(preset) {
      if (!backgroundWidget) {
        backgroundWidget = {
          type: "background",
          x: bgCanvas.width / 2,
          y: bgCanvas.height / 2,
          scale: 1,
          rotation: 0,
          opacity: 1,
          effectPreset: preset
        };
        widgets.push(backgroundWidget);
      } else {
        backgroundWidget.effectPreset = preset;
      }
      
      if (preset === "psychedelic") {
        // Reset psychedelic effect parameters
        psychedelicParams.zoom = 1.0;
        psychedelicParams.vignette = 0.5;
        psychedelicParams.colorShift = 0.3;
        psychedelicParams.redMultiplier = 1.0;
        psychedelicParams.greenMultiplier = 1.0;
        psychedelicParams.blueMultiplier = 1.0;
        psychedelicParams.pulseSpeed = 0.5;
        psychedelicParams.rotationSpeed = 0.2;
        psychedelicParams.colorBalance = 0.5;
        activeProgram = psychedelicProgram;
      } else if (preset === "glitch") {
        // Reset glitch effect parameters
        glitchParams.pixelSize = 100.0;
        glitchParams.jitterIntensity = 0.1;
        glitchParams.jitterSpeed = 2.0;
        glitchParams.compressionStrength = 0.2;
        glitchParams.rgbShiftAmount = 3.0;
        glitchParams.glitchInterval = 1.0;
        glitchParams.glitchAmount = 0.3;
        glitchParams.gradientIntensity = 0.0;
        glitchParams.asciiEffect = 0.0;
        glitchParams.asciiDensity = 1.0;
        activeProgram = glitchProgram;
      } else if (preset === "lensFlare") {
        // Reset lens flare effect parameters
        lensFlareParams.flareIntensity = 1.7;
        lensFlareParams.flarePosition[0] = 1.05;
        lensFlareParams.flarePosition[1] = -0.15;
        lensFlareParams.rainbowIntensity = 1.0;
        lensFlareParams.flareSpeed = 2.0;
        lensFlareParams.glareSize = 0.7;
        lensFlareParams.rayCount = 48;
        lensFlareParams.flareScale = 3.0;
        lensFlareParams.positionWiggle = 0.01;
        lensFlareParams.vignetteIntensity = 0.5;
        lensFlareParams.noiseIntensity = 0.1;
        lensFlareParams.zoomEffect = 1.0;
        lensFlareParams.zoomSpeed = 1.0;
        activeProgram = lensFlareProgram;
      }
      
      selectedWidget = backgroundWidget;
      updateWidgetControls();
      renderBackground();
    }
    
    // Create a texture from an image
    function createTexture(image) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      
      // Set the parameters so we can render any size image
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      
      // Upload the image into the texture
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      
      return texture;
    }
    
    // Handle background image upload
    document.getElementById('backgroundUpload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          // Create or update background widget
          if (!backgroundWidget) {
            backgroundWidget = {
              type: "background",
              x: bgCanvas.width / 2,
              y: bgCanvas.height / 2,
              scale: 1,
              image: img,
              effectPreset: "psychedelic" // Default effect
            };
          } else {
            backgroundWidget.image = img;
          }
          
          // Create texture from the image
          backgroundWidget.texture = createTexture(img);
          
          // Set as selected widget and update controls
          selectedWidget = backgroundWidget;
          updateWidgetControls();
          
          // Start rendering
          renderBackground();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });
    
    function renderBackground() {
      if (!backgroundWidget) return;
      
      if (backgroundWidget.effectPreset === "psychedelic" || 
          backgroundWidget.effectPreset === "glitch" || 
          backgroundWidget.effectPreset === "lensFlare") {
        
        // Use WebGL for effects
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Check if we have a texture to use
        if (!backgroundWidget.image || !backgroundWidget.texture) {
          // Draw a placeholder if no image is available
          ctx2d.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
          ctx2d.fillStyle = "#333";
          ctx2d.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
          ctx2d.strokeStyle = "#f00";
          ctx2d.lineWidth = 2;
          ctx2d.strokeRect(2, 2, bgCanvas.width - 4, bgCanvas.height - 4);
          ctx2d.fillStyle = "#fff";
          ctx2d.font = "16px sans-serif";
          ctx2d.textAlign = "center";
          ctx2d.fillText("Upload an image", bgCanvas.width / 2, bgCanvas.height / 2);
          return;
        }
        
        // Bind the texture
        gl.bindTexture(gl.TEXTURE_2D, backgroundWidget.texture);
        
        // Set the active program based on the effect
        if (backgroundWidget.effectPreset === "psychedelic") {
          gl.useProgram(psychedelicProgram);
          
          // Set attributes
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.enableVertexAttribArray(psychedelicLocations.a_position);
          gl.vertexAttribPointer(psychedelicLocations.a_position, 2, gl.FLOAT, false, 0, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
          gl.enableVertexAttribArray(psychedelicLocations.a_texCoord);
          gl.vertexAttribPointer(psychedelicLocations.a_texCoord, 2, gl.FLOAT, false, 0, 0);
          
          // Set uniforms
          gl.uniform2f(psychedelicLocations.u_resolution, gl.canvas.width, gl.canvas.height);
          gl.uniform1f(psychedelicLocations.u_zoom, psychedelicParams.zoom);
          gl.uniform1f(psychedelicLocations.u_vignette, psychedelicParams.vignette);
          gl.uniform1f(psychedelicLocations.u_colorShift, psychedelicParams.colorShift);
          gl.uniform1f(psychedelicLocations.u_redMultiplier, psychedelicParams.redMultiplier);
          gl.uniform1f(psychedelicLocations.u_greenMultiplier, psychedelicParams.greenMultiplier);
          gl.uniform1f(psychedelicLocations.u_blueMultiplier, psychedelicParams.blueMultiplier);
          gl.uniform1f(psychedelicLocations.u_pulseSpeed, psychedelicParams.pulseSpeed);
          gl.uniform1f(psychedelicLocations.u_rotationSpeed, psychedelicParams.rotationSpeed);
          gl.uniform1f(psychedelicLocations.u_colorBalance, psychedelicParams.colorBalance);
          gl.uniform1f(psychedelicLocations.u_time, performance.now() / 1000);
          
        } else if (backgroundWidget.effectPreset === "glitch") {
          gl.useProgram(glitchProgram);
          
          // Set attributes
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.enableVertexAttribArray(glitchLocations.a_position);
          gl.vertexAttribPointer(glitchLocations.a_position, 2, gl.FLOAT, false, 0, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
          gl.enableVertexAttribArray(glitchLocations.a_texCoord);
          gl.vertexAttribPointer(glitchLocations.a_texCoord, 2, gl.FLOAT, false, 0, 0);
          
          // Set uniforms
          gl.uniform2f(glitchLocations.u_resolution, gl.canvas.width, gl.canvas.height);
          gl.uniform1f(glitchLocations.u_time, performance.now() / 1000);
          gl.uniform1f(glitchLocations.u_pixelSize, glitchParams.pixelSize);
          gl.uniform1f(glitchLocations.u_jitterIntensity, glitchParams.jitterIntensity);
          gl.uniform1f(glitchLocations.u_jitterSpeed, glitchParams.jitterSpeed);
          gl.uniform1f(glitchLocations.u_compressionStrength, glitchParams.compressionStrength);
          gl.uniform1f(glitchLocations.u_rgbShiftAmount, glitchParams.rgbShiftAmount);
          gl.uniform1f(glitchLocations.u_glitchInterval, glitchParams.glitchInterval);
          gl.uniform1f(glitchLocations.u_glitchAmount, glitchParams.glitchAmount);
          gl.uniform1f(glitchLocations.u_gradientIntensity, glitchParams.gradientIntensity);
          gl.uniform1f(glitchLocations.u_asciiEffect, glitchParams.asciiEffect);
          gl.uniform1f(glitchLocations.u_asciiDensity, glitchParams.asciiDensity);
          
        } else if (backgroundWidget.effectPreset === "lensFlare") {
          gl.useProgram(lensFlareProgram);
          
          // Set attributes
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.enableVertexAttribArray(lensFlareLocations.a_position);
          gl.vertexAttribPointer(lensFlareLocations.a_position, 2, gl.FLOAT, false, 0, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
          gl.enableVertexAttribArray(lensFlareLocations.a_texCoord);
          gl.vertexAttribPointer(lensFlareLocations.a_texCoord, 2, gl.FLOAT, false, 0, 0);
          
          // Set uniforms
          gl.uniform2f(lensFlareLocations.u_resolution, gl.canvas.width, gl.canvas.height);
          gl.uniform1f(lensFlareLocations.u_time, performance.now() / 1000);
          gl.uniform1f(lensFlareLocations.u_flareIntensity, lensFlareParams.flareIntensity);
          gl.uniform2fv(lensFlareLocations.u_flarePosition, lensFlareParams.flarePosition);
          gl.uniform1f(lensFlareLocations.u_rainbowIntensity, lensFlareParams.rainbowIntensity);
          gl.uniform1f(lensFlareLocations.u_flareSpeed, lensFlareParams.flareSpeed);
          gl.uniform1f(lensFlareLocations.u_glareSize, lensFlareParams.glareSize);
          gl.uniform1f(lensFlareLocations.u_rayCount, lensFlareParams.rayCount);
          gl.uniform1f(lensFlareLocations.u_flareScale, lensFlareParams.flareScale);
          gl.uniform1f(lensFlareLocations.u_positionWiggle, lensFlareParams.positionWiggle);
          gl.uniform1f(lensFlareLocations.u_vignetteIntensity, lensFlareParams.vignetteIntensity);
          gl.uniform1f(lensFlareLocations.u_noiseIntensity, lensFlareParams.noiseIntensity);
          gl.uniform1f(lensFlareLocations.u_zoomEffect, lensFlareParams.zoomEffect);
          gl.uniform1f(lensFlareLocations.u_zoomSpeed, lensFlareParams.zoomSpeed);
        }
        
        // Draw the rectangle
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        
      } else {
        // Use 2D canvas for simple rendering
        ctx2d.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        
        if (backgroundWidget.image) {
          const width = backgroundWidget.image.width * backgroundWidget.scale;
          const height = backgroundWidget.image.height * backgroundWidget.scale;
          
          ctx2d.save();
          ctx2d.globalAlpha = backgroundWidget.opacity;
          ctx2d.translate(backgroundWidget.x, backgroundWidget.y);
          ctx2d.rotate(backgroundWidget.rotation * Math.PI / 180);
          ctx2d.drawImage(backgroundWidget.image, -width/2, -height/2, width, height);
          ctx2d.restore();
        }
      }
    }
    
    // Initialize the background with a default state
    function initBackground() {
      // Draw a placeholder until an image is uploaded using the overlay canvas
      ctx2d.fillStyle = "#333";
      ctx2d.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      ctx2d.strokeStyle = "#f00";
      ctx2d.lineWidth = 2;
      ctx2d.strokeRect(2, 2, overlayCanvas.width - 4, overlayCanvas.height - 4);
      ctx2d.fillStyle = "#fff";
      ctx2d.font = "16px sans-serif";
      ctx2d.textAlign = "center";
      ctx2d.fillText("Upload an image", overlayCanvas.width / 2, overlayCanvas.height / 2);
    }
    
    // Initialize the application
    function init() {
      initBackground();
      
      // Set up event listeners for sliders
      document.getElementById("vignetteSlider").addEventListener("input", function() {
        psychedelicParams.vignette = parseFloat(this.value);
        document.getElementById("vignetteValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("colorShiftSlider").addEventListener("input", function() {
        psychedelicParams.colorShift = parseFloat(this.value);
        document.getElementById("colorShiftValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("zoomSlider").addEventListener("input", function() {
        psychedelicParams.zoom = parseFloat(this.value);
        document.getElementById("zoomValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("redMultiplierSlider").addEventListener("input", function() {
        psychedelicParams.redMultiplier = parseFloat(this.value);
        document.getElementById("redMultiplierValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("greenMultiplierSlider").addEventListener("input", function() {
        psychedelicParams.greenMultiplier = parseFloat(this.value);
        document.getElementById("greenMultiplierValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("blueMultiplierSlider").addEventListener("input", function() {
        psychedelicParams.blueMultiplier = parseFloat(this.value);
        document.getElementById("blueMultiplierValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("pulseSpeedSlider").addEventListener("input", function() {
        psychedelicParams.pulseSpeed = parseFloat(this.value);
        document.getElementById("pulseSpeedValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("rotationSpeedSlider").addEventListener("input", function() {
        psychedelicParams.rotationSpeed = parseFloat(this.value);
        document.getElementById("rotationSpeedValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("colorBalanceSlider").addEventListener("input", function() {
        psychedelicParams.colorBalance = parseFloat(this.value);
        document.getElementById("colorBalanceValue").textContent = this.value;
        renderBackground();
      });
      
      // Glitch effect sliders
      document.getElementById("pixelSizeSlider").addEventListener("input", function() {
        glitchParams.pixelSize = parseFloat(this.value);
        document.getElementById("pixelSizeValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("jitterIntensitySlider").addEventListener("input", function() {
        glitchParams.jitterIntensity = parseFloat(this.value);
        document.getElementById("jitterIntensityValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("jitterSpeedSlider").addEventListener("input", function() {
        glitchParams.jitterSpeed = parseFloat(this.value);
        document.getElementById("jitterSpeedValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("compressionStrengthSlider").addEventListener("input", function() {
        glitchParams.compressionStrength = parseFloat(this.value);
        document.getElementById("compressionStrengthValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("rgbShiftAmountSlider").addEventListener("input", function() {
        glitchParams.rgbShiftAmount = parseFloat(this.value);
        document.getElementById("rgbShiftAmountValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("glitchIntervalSlider").addEventListener("input", function() {
        glitchParams.glitchInterval = parseFloat(this.value);
        document.getElementById("glitchIntervalValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("glitchAmountSlider").addEventListener("input", function() {
        glitchParams.glitchAmount = parseFloat(this.value);
        document.getElementById("glitchAmountValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("purpleTintSlider").addEventListener("input", function() {
        glitchParams.gradientIntensity = parseFloat(this.value);
        document.getElementById("purpleTintValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("asciiEffectSlider").addEventListener("input", function() {
        glitchParams.asciiEffect = parseFloat(this.value);
        document.getElementById("asciiEffectValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("asciiDensitySlider").addEventListener("input", function() {
        glitchParams.asciiDensity = parseFloat(this.value);
        document.getElementById("asciiDensityValue").textContent = this.value;
        renderBackground();
      });
      
      // Add event listeners for lens flare controls
      document.getElementById("flareIntensitySlider").addEventListener("input", function() {
        lensFlareParams.flareIntensity = parseFloat(this.value);
        document.getElementById("flareIntensityValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("flarePosXSlider").addEventListener("input", function() {
        lensFlareParams.flarePosition[0] = parseFloat(this.value);
        document.getElementById("flarePosXValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("flarePosYSlider").addEventListener("input", function() {
        lensFlareParams.flarePosition[1] = parseFloat(this.value);
        document.getElementById("flarePosYValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("flareScaleSlider").addEventListener("input", function() {
        lensFlareParams.flareScale = parseFloat(this.value);
        document.getElementById("flareScaleValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("positionWiggleSlider").addEventListener("input", function() {
        lensFlareParams.positionWiggle = parseFloat(this.value);
        document.getElementById("positionWiggleValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("rainbowIntensitySlider").addEventListener("input", function() {
        lensFlareParams.rainbowIntensity = parseFloat(this.value);
        document.getElementById("rainbowIntensityValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("flareSpeedSlider").addEventListener("input", function() {
        lensFlareParams.flareSpeed = parseFloat(this.value);
        document.getElementById("flareSpeedValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("glareSizeSlider").addEventListener("input", function() {
        lensFlareParams.glareSize = parseFloat(this.value);
        document.getElementById("glareSizeValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("rayCountSlider").addEventListener("input", function() {
        lensFlareParams.rayCount = parseFloat(this.value);
        document.getElementById("rayCountValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("vignetteIntensitySlider").addEventListener("input", function() {
        lensFlareParams.vignetteIntensity = parseFloat(this.value);
        document.getElementById("vignetteIntensityValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("noiseIntensitySlider").addEventListener("input", function() {
        lensFlareParams.noiseIntensity = parseFloat(this.value);
        document.getElementById("noiseIntensityValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("zoomEffectSlider").addEventListener("input", function() {
        lensFlareParams.zoomEffect = parseFloat(this.value);
        document.getElementById("zoomEffectValue").textContent = this.value;
        renderBackground();
      });
      
      document.getElementById("zoomSpeedSlider").addEventListener("input", function() {
        lensFlareParams.zoomSpeed = parseFloat(this.value);
        document.getElementById("zoomSpeedValue").textContent = this.value;
        renderBackground();
      });
      
      // Start animation loop for effects that need continuous updates
      startAnimationLoop();
    }
    
    // Animation loop for continuous effects
    function startAnimationLoop() {
      function animate() {
        // Only re-render if we have a background with an animated effect
        if (backgroundWidget && 
            (backgroundWidget.effectPreset === "psychedelic" || 
             backgroundWidget.effectPreset === "glitch" || 
             backgroundWidget.effectPreset === "lensFlare")) {
          renderBackground();
        }
        requestAnimationFrame(animate);
      }
      
      // Start the animation loop
      animate();
    }
    
    // Call init to set up the application
    init();
    
    /***** Text Widget Functions *****/
    function addTextWidget() {
      const text = document.getElementById("textInput").value;
      if (!text) return;
      
      const font = document.getElementById("fontSelect").value;
      const color = document.getElementById("colorSelect").value;
      
      const textWidget = {
        type: "text",
        text: text,
        font: font,
        color: color,
        x: overlayCanvas.width / 2,
        y: overlayCanvas.height / 2,
        scale: 1,
        rotation: 0,
        effectPreset: "none"
      };
      
      widgets.push(textWidget);
      selectedWidget = textWidget;
      updateWidgetControls();
      renderOverlay();
    }
    
    function updateSelectedTextWidget() {
      if (!selectedWidget || selectedWidget.type !== "text") return;
      
      selectedWidget.text = document.getElementById("editTextInput").value;
      selectedWidget.font = document.getElementById("editFontSelect").value;
      selectedWidget.color = document.getElementById("editColorSelect").value;
      selectedWidget.rotation = parseInt(document.getElementById("textRotationSlider").value);
      
      renderOverlay();
    }
    
    function applyTextEffectPreset(preset) {
      if (!selectedWidget || selectedWidget.type !== "text") return;
      
      selectedWidget.effectPreset = preset;
      renderOverlay();
    }
    
    /***** Sticker Widget Functions *****/
    function addStickerFromLibrary() {
      // Create a default sticker (a simple colored square for now)
      const stickerWidget = {
        type: "sticker",
        x: overlayCanvas.width / 2,
        y: overlayCanvas.height / 2,
        scale: 1,
        rotation: 0,
        color: "#" + Math.floor(Math.random()*16777215).toString(16) // Random color
      };
      
      widgets.push(stickerWidget);
      selectedWidget = stickerWidget;
      updateWidgetControls();
      renderOverlay();
    }
    
    document.getElementById('stickerUpload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          const stickerWidget = {
            type: "sticker",
            image: img,
            x: overlayCanvas.width / 2,
            y: overlayCanvas.height / 2,
            scale: 1,
            rotation: 0
          };
          
          widgets.push(stickerWidget);
          selectedWidget = stickerWidget;
          updateWidgetControls();
          renderOverlay();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });
    
    function removeSelectedWidget() {
      if (!selectedWidget) return;
      
      if (selectedWidget.type === "background") {
        backgroundWidget = null;
      } else {
        const index = widgets.indexOf(selectedWidget);
        if (index > -1) {
          widgets.splice(index, 1);
        }
      }
      
      selectedWidget = null;
      updateWidgetControls();
      renderOverlay();
    }
    
    /***** Overlay Rendering *****/
    function renderOverlay() {
      ctx2d.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      
      // Draw all widgets
      widgets.forEach(widget => {
        if (widget.type === "text") {
          renderTextWidget(widget);
        } else if (widget.type === "sticker") {
          renderStickerWidget(widget);
        }
      });
      
      // Draw selection outline if a widget is selected
      if (selectedWidget && selectedWidget.type !== "background") {
        const bounds = getWidgetBounds(selectedWidget);
        ctx2d.strokeStyle = "#00f";
        ctx2d.lineWidth = 2;
        ctx2d.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
        
        // Draw resize handle
        ctx2d.fillStyle = "#00f";
        const handleSize = 10;
        ctx2d.fillRect(bounds.x + bounds.width - handleSize, bounds.y + bounds.height - handleSize, handleSize, handleSize);
      }
    }
    
    function renderTextWidget(widget) {
      ctx2d.save();
      
      // Set up text properties
      ctx2d.font = "30px " + widget.font;
      ctx2d.fillStyle = widget.color;
      ctx2d.textAlign = "center";
      ctx2d.textBaseline = "middle";
      
      // Apply transformations
      ctx2d.translate(widget.x, widget.y);
      ctx2d.scale(widget.scale, widget.scale);
      if (widget.rotation) {
        ctx2d.rotate(widget.rotation * Math.PI / 180);
      }
      
      // Draw the text
      ctx2d.fillText(widget.text, 0, 0);
      
      ctx2d.restore();
    }
    
    function renderStickerWidget(widget) {
      ctx2d.save();
      
      // Apply transformations
      ctx2d.translate(widget.x, widget.y);
      ctx2d.scale(widget.scale, widget.scale);
      if (widget.rotation) {
        ctx2d.rotate(widget.rotation * Math.PI / 180);
      }
      
      // Draw the sticker
      if (widget.image) {
        const width = widget.image.width;
        const height = widget.image.height;
        ctx2d.drawImage(widget.image, -width/2, -height/2);
      } else if (widget.color) {
        // Draw a colored square as a fallback
        ctx2d.fillStyle = widget.color;
        ctx2d.fillRect(-25, -25, 50, 50);
      }
      
      ctx2d.restore();
    }
    
    /***** Event Listeners for Widget Interaction *****/
    overlayCanvas.addEventListener("mousedown", function(e) {
      const rect = overlayCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Check if we're clicking on the resize handle of the selected widget
      if (selectedWidget && selectedWidget.type !== "background" && 
          widgetScaleHandleContainsPoint(selectedWidget, x, y)) {
        isScaling = true;
        initialScale = selectedWidget.scale;
        initialMouseDist = Math.sqrt(
          Math.pow(x - selectedWidget.x, 2) + 
          Math.pow(y - selectedWidget.y, 2)
        );
        return;
      }
      
      // Check if we're clicking on any widget
      let clickedWidget = null;
      
      // Check regular widgets first (in reverse order to get top-most widget)
      for (let i = widgets.length - 1; i >= 0; i--) {
        if (widgetContainsPoint(widgets[i], x, y)) {
          clickedWidget = widgets[i];
          break;
        }
      }
      
      // If no regular widget was clicked, check if background was clicked
      if (!clickedWidget && backgroundWidget && 
          widgetContainsPoint(backgroundWidget, x, y)) {
        clickedWidget = backgroundWidget;
      }
      
      if (clickedWidget) {
        selectedWidget = clickedWidget;
        isDragging = true;
        dragOffset.x = x - clickedWidget.x;
        dragOffset.y = y - clickedWidget.y;
      } else {
        selectedWidget = null;
      }
      
      updateWidgetControls();
      renderOverlay();
    });
    
    overlayCanvas.addEventListener("mousemove", function(e) {
      const rect = overlayCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      if (isDragging && selectedWidget) {
        selectedWidget.x = x - dragOffset.x;
        selectedWidget.y = y - dragOffset.y;
        renderOverlay();
      } else if (isScaling && selectedWidget) {
        const currentDist = Math.sqrt(
          Math.pow(x - selectedWidget.x, 2) + 
          Math.pow(y - selectedWidget.y, 2)
        );
        selectedWidget.scale = initialScale * (currentDist / initialMouseDist);
        renderOverlay();
      }
    });
    
    window.addEventListener("mouseup", function() {
      isDragging = false;
      isScaling = false;
    });
  </script>
</body>
</html>
