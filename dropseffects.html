<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=720, height=1280" />
  <title>Content Creation Tool with WebGL Warping</title>
  <!-- Import available Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Asap+Condensed&family=Damion&family=Sigmar+One&family=Lobster&family=Lato&family=Baskervville&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    .toolbar {
      width: 250px;
      background: #f0f0f0;
      padding: 10px;
      overflow-y: auto;
      border-right: 1px solid #ccc;
    }
    .toolbar h3 { margin-top: 20px; }
    .control-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; }
    #widgetControls {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      background: #fff;
      display: none;
    }
    #psychedelicControls {
      margin-top: 10px;
      display: none;
    }
    #psychedelicControls label { font-size: 0.9em; margin-top: 5px; }
    #glitchControls {
      margin-top: 10px;
      display: none;
    }
    #glitchControls label { font-size: 0.9em; margin-top: 5px; }
    .editor {
      position: relative;
      width: 720px;
      height: 1280px;
      background: #ddd;
    }
    #bgCanvas, #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 720px;
      height: 1280px;
    }
    #bgCanvas { z-index: 0; }
    #overlayCanvas {
      z-index: 1;
      background: transparent;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <h3>Background Widget</h3>
    <div class="control-group">
      <label for="backgroundUpload">Upload Background</label>
      <input type="file" id="backgroundUpload" accept="image/*" />
    </div>
    <div class="control-group">
      <label>Effect Presets</label>
      <button onclick="applyBackgroundPreset('psychedelic')">Psychedelic</button>
      <button onclick="applyBackgroundPreset('glitch')">Glitch</button>
      <button onclick="applyBackgroundPreset('lensFlare')">Lens Flare</button>
    </div>
    <hr />
    <div id="widgetControls">
      <h3>Widget Controls</h3>
      <button onclick="removeSelectedWidget()">Remove Widget</button>
      
      <div id="psychedelicControls">
        <label>
          Vignette Intensity: <span id="vignetteValue">0.5</span>
        </label>
        <input type="range" id="vignetteSlider" min="0" max="1" step="0.01" value="0.5">
        <label>
          Color Shift Offset: <span id="colorShiftValue">5</span>
        </label>
        <input type="range" id="colorShiftSlider" min="0" max="20" step="1" value="5">
        <label>
          Zoom Factor: <span id="zoomValue">1.2</span>
        </label>
        <!-- Wider zoom range: from 0.5 to 3.0 -->
        <input type="range" id="zoomSlider" min="0.5" max="3.0" step="0.01" value="1.2">
        <label>
          Red Channel Multiplier: <span id="redMultiplierValue">1.0</span>
        </label>
        <input type="range" id="redMultiplierSlider" min="0" max="2" step="0.1" value="1.0">
        <label>
          Green Channel Multiplier: <span id="greenMultiplierValue">0.6</span>
        </label>
        <input type="range" id="greenMultiplierSlider" min="0" max="2" step="0.1" value="0.6">
        <label>
          Blue Channel Multiplier: <span id="blueMultiplierValue">1.0</span>
        </label>
        <input type="range" id="blueMultiplierSlider" min="0" max="2" step="0.1" value="1.0">
        <label>
          Pulse Speed: <span id="pulseSpeedValue">0.0</span>
        </label>
        <input type="range" id="pulseSpeedSlider" min="0" max="5" step="0.1" value="0.0">
        <label>
          Rotation Speed: <span id="rotationSpeedValue">0.0</span>
        </label>
        <input type="range" id="rotationSpeedSlider" min="0" max="10" step="0.1" value="0.0">
        <label>
          Color Balance: <span id="colorBalanceValue">0.4</span>
        </label>
        <input type="range" id="colorBalanceSlider" min="0" max="1" step="0.01" value="0.4">
      </div>
      <div id="glitchControls">
        <label>
          Pixel Size: <span id="pixelSizeValue">1.1</span>
        </label>
        <input type="range" id="pixelSizeSlider" min="0.1" max="50" step="0.1" value="1.1">
        <label>
          Pixel Spacing: <span id="pixelSpacingValue">0.26</span>
        </label>
        <input type="range" id="pixelSpacingSlider" min="0" max="0.5" step="0.01" value="0.26">
        <label>
          Scale: <span id="glitchScaleValue">1.3</span>
        </label>
        <input type="range" id="glitchScaleSlider" min="0.1" max="3.0" step="0.1" value="1.3">
        
        <!-- Add glow control -->
        <label>
          Glow Intensity: <span id="glowIntensityValue">0.0</span>
        </label>
        <input type="range" id="glowIntensitySlider" min="0" max="2" step="0.1" value="0.0">
        
        <!-- Add wave animation controls -->
        <label>
          Wave Speed: <span id="waveSpeedValue">0.4</span>
        </label>
        <input type="range" id="waveSpeedSlider" min="0" max="5" step="0.1" value="0.4">
        
        <label>
          Wave Amplitude: <span id="waveAmplitudeValue">0.007</span>
        </label>
        <input type="range" id="waveAmplitudeSlider" min="0" max="0.1" step="0.001" value="0.007">
        
        <!-- Add wave size control -->
        <label>
          Wave Size: <span id="waveSizeValue">10.0</span>
        </label>
        <input type="range" id="waveSizeSlider" min="1" max="50" step="1" value="10">
        
        <!-- Add tint controls -->
        <div style="margin-top: 15px; border-top: 1px solid #ccc; padding-top: 15px;">
          <label>Tint Controls</label>
          <div>
            <label>Map Black To:</label>
            <input type="color" id="tintBlackColor" value="#2A0A4A">
          </div>
          <div>
            <label>Map White To:</label>
            <input type="color" id="tintWhiteColor" value="#E6D5FF">
          </div>
          <div>
            <label>
              Tint Amount: <span id="tintAmountValue">100.0</span>%
            </label>
            <input type="range" id="tintAmountSlider" min="0" max="100" step="1" value="100">
          </div>
        </div>
        
        <!-- Add tint controls -->
        <div style="margin-top: 15px; border-top: 1px solid #ccc; padding-top: 15px;">
          <label>Pattern Style</label>
          <div>
            <label>
              <input type="checkbox" id="patternStyleToggle"> Use Geometric Patterns
            </label>
          </div>
        </div>
      </div>
      
      <div id="lensFlareControls">
        <label>
          Flare Intensity: <span id="flareIntensityValue">1.3</span>
        </label>
        <input type="range" id="flareIntensitySlider" min="0" max="2" step="0.1" value="1.3">
        <label>
          Flare Position X: <span id="flarePosXValue">1.3</span>
        </label>
        <input type="range" id="flarePosXSlider" min="-0.5" max="1.5" step="0.01" value="1.3">
        <label>
          Flare Position Y: <span id="flarePosYValue">-0.33</span>
        </label>
        <input type="range" id="flarePosYSlider" min="-0.5" max="1.5" step="0.01" value="-0.33">
        <label>
          Flare Scale: <span id="flareScaleValue">3.0</span>
        </label>
        <input type="range" id="flareScaleSlider" min="0.2" max="3.0" step="0.1" value="3.0">
        <label>
          Position Wiggle: <span id="positionWiggleValue">0.01</span>
        </label>
        <input type="range" id="positionWiggleSlider" min="0" max="0.1" step="0.01" value="0.01">
        <label>
          Rainbow Intensity: <span id="rainbowIntensityValue">1.0</span>
        </label>
        <input type="range" id="rainbowIntensitySlider" min="0" max="1" step="0.1" value="1.0">
        <label>
          Animation Speed: <span id="flareSpeedValue">2.0</span>
        </label>
        <input type="range" id="flareSpeedSlider" min="0" max="2" step="0.1" value="2.0">
        <label>
          Glow Size: <span id="glareSizeValue">0.6</span>
        </label>
        <input type="range" id="glareSizeSlider" min="0.1" max="1" step="0.1" value="0.6">
        <label>
          Ray Count: <span id="rayCountValue">48</span>
        </label>
        <input type="range" id="rayCountSlider" min="8" max="48" step="4" value="48">
        <label>
          Vignette Intensity: <span id="vignetteIntensityValue">0.2</span>
        </label>
        <input type="range" id="vignetteIntensitySlider" min="0" max="1" step="0.1" value="0.2">
        <label>
          Noise Intensity: <span id="noiseIntensityValue">0.3</span>
        </label>
        <input type="range" id="noiseIntensitySlider" min="0" max="0.3" step="0.01" value="0.3">
        <label>
          Zoom Effect: <span id="zoomEffectValue">0.3</span>
        </label>
        <input type="range" id="zoomEffectSlider" min="0" max="1" step="0.01" value="0.3">
        <label>
          Zoom Speed: <span id="zoomSpeedValue">0.06</span>
        </label>
        <input type="range" id="zoomSpeedSlider" min="0" max="0.5" step="0.01" value="0.06">
      </div>
    </div>
    <div class="control-group">
      <h3>Background Effects</h3>
      <button onclick="applyBackgroundEffect('psychedelic')">Psychedelic</button>
      <button onclick="applyBackgroundEffect('glitch')">Glitch</button>
      <button onclick="applyBackgroundEffect('lensFlare')">Lens Flare</button>
      <button onclick="applyBackgroundEffect('none')">None</button>
    </div>
  </div>
  <div class="editor">
    <canvas id="bgCanvas" width="720" height="1280"></canvas>
    <canvas id="overlayCanvas" width="720" height="1280"></canvas>
  </div>
  <script>
    // Global variables
    let gl;
    let activeProgram;
    let backgroundWidget;
    let selectedWidget;
    let ctx2d;
    let positionBuffer;
    let texCoordBuffer;
    let psychedelicProgram;
    let glitchProgram;
    let lensFlareProgram;

    // Shader locations
    const psychedelicLocations = {
      a_position: null,
      a_texCoord: null,
      u_image: null,
      u_resolution: null,
      u_zoom: null,
      u_vignette: null,
      u_colorShift: null,
      u_redMultiplier: null,
      u_greenMultiplier: null,
      u_blueMultiplier: null,
      u_pulseSpeed: null,
      u_rotationSpeed: null,
      u_colorBalance: null,
      u_time: null
    };

    const glitchLocations = {
      a_position: null,
      a_texCoord: null,
      u_image: null,
      u_resolution: null,
      u_time: null,
      u_pixelSize: null,
      u_scale: null,
      u_spacing: null,
      u_tintBlackColor: null,
      u_tintWhiteColor: null,
      u_tintAmount: null,
      u_useGeometricPatterns: null,
      u_glowIntensity: null,
      u_waveSpeed: null,
      u_waveAmplitude: null,
      u_waveSize: null
    };

    const lensFlareLocations = {
      a_position: null,
      a_texCoord: null,
      u_image: null,
      u_resolution: null,
      u_time: null,
      u_flareIntensity: null,
      u_flarePosition: null,
      u_rainbowIntensity: null,
      u_flareSpeed: null,
      u_glareSize: null,
      u_rayCount: null,
      u_flareScale: null,
      u_positionWiggle: null,
      u_vignetteIntensity: null,
      u_noiseIntensity: null,
      u_zoomEffect: null,
      u_zoomSpeed: null
    };

    // Effect parameters
    const psychedelicParams = {
      vignette: 0.5,
      colorShift: 5,
      zoom: 1.2,
      redMultiplier: 1.0,
      greenMultiplier: 0.6,
      blueMultiplier: 1.0,
      pulseSpeed: 0.0,
      rotationSpeed: 0.0,
      colorBalance: 0.4
    };

    const glitchParams = {
      pixelSize: 1.1,
      scale: 1.3,
      spacing: 0.26,
      tintBlackColor: [0.165, 0.039, 0.290],
      tintWhiteColor: [0.902, 0.835, 1.000],
      tintAmount: 1.0,
      useGeometricPatterns: false,
      glowIntensity: 0.0,
      waveSpeed: 0.4,
      waveAmplitude: 0.007,
      waveSize: 10.0
    };

    const lensFlareParams = {
      flareIntensity: 1.3,
      flarePosX: 1.3,
      flarePosY: -0.33,
      flareScale: 3.0,
      positionWiggle: 0.01,
      rainbowIntensity: 1.0,
      flareSpeed: 2.0,
      glareSize: 0.6,
      rayCount: 48,
      vignetteIntensity: 0.2,
      noiseIntensity: 0.3,
      zoomEffect: 0.3,
      zoomSpeed: 0.06
    };

    // Initialize WebGL context
    function initWebGL() {
      const canvas = document.getElementById('bgCanvas');
      gl = canvas.getContext('webgl');
      if (!gl) {
        console.error('WebGL not supported');
        return;
      }

      // Initialize 2D context for fallback
      ctx2d = canvas.getContext('2d');

      // Create buffers
      positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1.0, -1.0,
         1.0, -1.0,
        -1.0,  1.0,
         1.0,  1.0,
        -1.0,  1.0,
         1.0, -1.0,
      ]), gl.STATIC_DRAW);

      texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,
        1.0, 1.0,
        0.0, 1.0,
        1.0, 0.0,
      ]), gl.STATIC_DRAW);

      // Compile shaders
      const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
      const psychedelicFragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
      const glitchFragmentShader = compileShader(gl, glitchShaderSource, gl.FRAGMENT_SHADER);
      const lensFlareFragmentShader = compileShader(gl, lensFlareShaderSource, gl.FRAGMENT_SHADER);

      // Create shader programs
      psychedelicProgram = createProgram(gl, vertexShader, psychedelicFragmentShader);
      glitchProgram = createProgram(gl, vertexShader, glitchFragmentShader);
      lensFlareProgram = createProgram(gl, vertexShader, lensFlareFragmentShader);

      // Set initial active program
      activeProgram = psychedelicProgram;

      // Initialize shader locations
      initShaderLocations(psychedelicProgram, psychedelicLocations);
      initShaderLocations(glitchProgram, glitchLocations);
      initShaderLocations(lensFlareProgram, lensFlareLocations);
    }

    // Helper function to compile shaders
    function compileShader(gl, shaderSource, shaderType) {
      const shader = gl.createShader(shaderType);
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);
      
      // Check for compilation errors
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(shader);
        console.error("Shader compile failed:", error);
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // Helper function to create shader program
    function createProgram(gl, vertexShader, fragmentShader) {
      if (!vertexShader || !fragmentShader) {
        console.error("Cannot create program: shaders are null");
        return null;
      }

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      
      // Check for linking errors
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = gl.getProgramInfoLog(program);
        console.error("Program link failed:", error);
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    // Initialize shader locations
    function initShaderLocations(program, locations) {
      locations.a_position = gl.getAttribLocation(program, 'a_position');
      locations.a_texCoord = gl.getAttribLocation(program, 'a_texCoord');
      locations.u_image = gl.getUniformLocation(program, 'u_image');
      locations.u_resolution = gl.getUniformLocation(program, 'u_resolution');
      locations.u_time = gl.getUniformLocation(program, 'u_time');
      
      // Add other locations based on the shader type
      if (program === psychedelicProgram) {
        locations.u_zoom = gl.getUniformLocation(program, 'u_zoom');
        locations.u_vignette = gl.getUniformLocation(program, 'u_vignette');
        locations.u_colorShift = gl.getUniformLocation(program, 'u_colorShift');
        locations.u_redMultiplier = gl.getUniformLocation(program, 'u_redMultiplier');
        locations.u_greenMultiplier = gl.getUniformLocation(program, 'u_greenMultiplier');
        locations.u_blueMultiplier = gl.getUniformLocation(program, 'u_blueMultiplier');
        locations.u_pulseSpeed = gl.getUniformLocation(program, 'u_pulseSpeed');
        locations.u_rotationSpeed = gl.getUniformLocation(program, 'u_rotationSpeed');
        locations.u_colorBalance = gl.getUniformLocation(program, 'u_colorBalance');
      } else if (program === glitchProgram) {
        locations.u_pixelSize = gl.getUniformLocation(program, 'u_pixelSize');
        locations.u_scale = gl.getUniformLocation(program, 'u_scale');
        locations.u_spacing = gl.getUniformLocation(program, 'u_spacing');
        locations.u_tintBlackColor = gl.getUniformLocation(program, 'u_tintBlackColor');
        locations.u_tintWhiteColor = gl.getUniformLocation(program, 'u_tintWhiteColor');
        locations.u_tintAmount = gl.getUniformLocation(program, 'u_tintAmount');
        locations.u_useGeometricPatterns = gl.getUniformLocation(program, 'u_useGeometricPatterns');
        locations.u_glowIntensity = gl.getUniformLocation(program, 'u_glowIntensity');
        locations.u_waveSpeed = gl.getUniformLocation(program, 'u_waveSpeed');
        locations.u_waveAmplitude = gl.getUniformLocation(program, 'u_waveAmplitude');
        locations.u_waveSize = gl.getUniformLocation(program, 'u_waveSize');
      } else if (program === lensFlareProgram) {
        locations.u_flareIntensity = gl.getUniformLocation(program, 'u_flareIntensity');
        locations.u_flarePosition = gl.getUniformLocation(program, 'u_flarePosition');
        locations.u_rainbowIntensity = gl.getUniformLocation(program, 'u_rainbowIntensity');
        locations.u_flareSpeed = gl.getUniformLocation(program, 'u_flareSpeed');
        locations.u_glareSize = gl.getUniformLocation(program, 'u_glareSize');
        locations.u_rayCount = gl.getUniformLocation(program, 'u_rayCount');
        locations.u_flareScale = gl.getUniformLocation(program, 'u_flareScale');
        locations.u_positionWiggle = gl.getUniformLocation(program, 'u_positionWiggle');
        locations.u_vignetteIntensity = gl.getUniformLocation(program, 'u_vignetteIntensity');
        locations.u_noiseIntensity = gl.getUniformLocation(program, 'u_noiseIntensity');
        locations.u_zoomEffect = gl.getUniformLocation(program, 'u_zoomEffect');
        locations.u_zoomSpeed = gl.getUniformLocation(program, 'u_zoomSpeed');
      }
    }

    // Initialize WebGL when the document is ready
    document.addEventListener('DOMContentLoaded', function() {
      initWebGL();
      
      // Set up event listeners for psychedelic effect controls
      document.getElementById('vignetteSlider').addEventListener('input', function(e) {
        psychedelicParams.vignette = parseFloat(e.target.value);
        document.getElementById('vignetteValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('colorShiftSlider').addEventListener('input', function(e) {
        psychedelicParams.colorShift = parseFloat(e.target.value);
        document.getElementById('colorShiftValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('zoomSlider').addEventListener('input', function(e) {
        psychedelicParams.zoom = parseFloat(e.target.value);
        document.getElementById('zoomValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('redMultiplierSlider').addEventListener('input', function(e) {
        psychedelicParams.redMultiplier = parseFloat(e.target.value);
        document.getElementById('redMultiplierValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('greenMultiplierSlider').addEventListener('input', function(e) {
        psychedelicParams.greenMultiplier = parseFloat(e.target.value);
        document.getElementById('greenMultiplierValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('blueMultiplierSlider').addEventListener('input', function(e) {
        psychedelicParams.blueMultiplier = parseFloat(e.target.value);
        document.getElementById('blueMultiplierValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('pulseSpeedSlider').addEventListener('input', function(e) {
        psychedelicParams.pulseSpeed = parseFloat(e.target.value);
        document.getElementById('pulseSpeedValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('rotationSpeedSlider').addEventListener('input', function(e) {
        psychedelicParams.rotationSpeed = parseFloat(e.target.value);
        document.getElementById('rotationSpeedValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('colorBalanceSlider').addEventListener('input', function(e) {
        psychedelicParams.colorBalance = parseFloat(e.target.value);
        document.getElementById('colorBalanceValue').textContent = e.target.value;
        renderBackground();
      });
      
      // Set up event listeners for glitch effect controls
      document.getElementById('pixelSizeSlider').addEventListener('input', function(e) {
        glitchParams.pixelSize = parseFloat(e.target.value);
        document.getElementById('pixelSizeValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('pixelSpacingSlider').addEventListener('input', function(e) {
        glitchParams.spacing = parseFloat(e.target.value);
        document.getElementById('pixelSpacingValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('glitchScaleSlider').addEventListener('input', function(e) {
        glitchParams.scale = parseFloat(e.target.value);
        document.getElementById('glitchScaleValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('glowIntensitySlider').addEventListener('input', function(e) {
        glitchParams.glowIntensity = parseFloat(e.target.value);
        document.getElementById('glowIntensityValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('waveSpeedSlider').addEventListener('input', function(e) {
        glitchParams.waveSpeed = parseFloat(e.target.value);
        document.getElementById('waveSpeedValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('waveAmplitudeSlider').addEventListener('input', function(e) {
        glitchParams.waveAmplitude = parseFloat(e.target.value);
        document.getElementById('waveAmplitudeValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('waveSizeSlider').addEventListener('input', function(e) {
        glitchParams.waveSize = parseFloat(e.target.value);
        document.getElementById('waveSizeValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('tintAmountSlider').addEventListener('input', function(e) {
        glitchParams.tintAmount = parseFloat(e.target.value) / 100.0;
        document.getElementById('tintAmountValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('tintBlackColor').addEventListener('input', function(e) {
        const color = e.target.value;
        glitchParams.tintBlackColor = [
          parseInt(color.substr(1, 2), 16) / 255.0,
          parseInt(color.substr(3, 2), 16) / 255.0,
          parseInt(color.substr(5, 2), 16) / 255.0
        ];
        renderBackground();
      });
      
      document.getElementById('tintWhiteColor').addEventListener('input', function(e) {
        const color = e.target.value;
        glitchParams.tintWhiteColor = [
          parseInt(color.substr(1, 2), 16) / 255.0,
          parseInt(color.substr(3, 2), 16) / 255.0,
          parseInt(color.substr(5, 2), 16) / 255.0
        ];
        renderBackground();
      });
      
      document.getElementById('patternStyleToggle').addEventListener('change', function(e) {
        glitchParams.useGeometricPatterns = e.target.checked;
        renderBackground();
      });
      
      // Set up event listeners for lens flare effect controls
      document.getElementById('flareIntensitySlider').addEventListener('input', function(e) {
        lensFlareParams.flareIntensity = parseFloat(e.target.value);
        document.getElementById('flareIntensityValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('flarePosXSlider').addEventListener('input', function(e) {
        lensFlareParams.flarePosX = parseFloat(e.target.value);
        document.getElementById('flarePosXValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('flarePosYSlider').addEventListener('input', function(e) {
        lensFlareParams.flarePosY = parseFloat(e.target.value);
        document.getElementById('flarePosYValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('flareScaleSlider').addEventListener('input', function(e) {
        lensFlareParams.flareScale = parseFloat(e.target.value);
        document.getElementById('flareScaleValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('positionWiggleSlider').addEventListener('input', function(e) {
        lensFlareParams.positionWiggle = parseFloat(e.target.value);
        document.getElementById('positionWiggleValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('rainbowIntensitySlider').addEventListener('input', function(e) {
        lensFlareParams.rainbowIntensity = parseFloat(e.target.value);
        document.getElementById('rainbowIntensityValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('flareSpeedSlider').addEventListener('input', function(e) {
        lensFlareParams.flareSpeed = parseFloat(e.target.value);
        document.getElementById('flareSpeedValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('glareSizeSlider').addEventListener('input', function(e) {
        lensFlareParams.glareSize = parseFloat(e.target.value);
        document.getElementById('glareSizeValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('rayCountSlider').addEventListener('input', function(e) {
        lensFlareParams.rayCount = parseInt(e.target.value);
        document.getElementById('rayCountValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('vignetteIntensitySlider').addEventListener('input', function(e) {
        lensFlareParams.vignetteIntensity = parseFloat(e.target.value);
        document.getElementById('vignetteIntensityValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('noiseIntensitySlider').addEventListener('input', function(e) {
        lensFlareParams.noiseIntensity = parseFloat(e.target.value);
        document.getElementById('noiseIntensityValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('zoomEffectSlider').addEventListener('input', function(e) {
        lensFlareParams.zoomEffect = parseFloat(e.target.value);
        document.getElementById('zoomEffectValue').textContent = e.target.value;
        renderBackground();
      });
      
      document.getElementById('zoomSpeedSlider').addEventListener('input', function(e) {
        lensFlareParams.zoomSpeed = parseFloat(e.target.value);
        document.getElementById('zoomSpeedValue').textContent = e.target.value;
        renderBackground();
      });
    });

    // Handle background image upload
    document.getElementById('backgroundUpload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          if (!backgroundWidget) {
            backgroundWidget = {
              type: "background",
              x: bgCanvas.width / 2,
              y: bgCanvas.height / 2,
              scale: 1,
              image: img,
              effectPreset: "psychedelic"
            };
          } else {
            backgroundWidget.image = img;
          }
          
          backgroundWidget.texture = createTexture(img);
          selectedWidget = backgroundWidget;
          updateWidgetControls();
          renderBackground();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Create a texture from an image
    function createTexture(image) {
      if (!gl) {
        console.error("WebGL context not initialized");
        return null;
      }
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      
      // Set the parameters so we can render any size image
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      
      // Upload the image into the texture
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      
      return texture;
    }
    
    // Vertex shader is shared between all effects
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main(){
        gl_Position = vec4(a_position, 0, 1);
        v_texCoord = a_texCoord;
      }
    `;
    
    // Psychedelic shader
    const fragmentShaderSource = `
      precision mediump float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_zoom;
      uniform float u_vignette;
      uniform float u_colorShift;
      uniform float u_redMultiplier;
      uniform float u_greenMultiplier;
      uniform float u_blueMultiplier;
      uniform float u_pulseSpeed;
      uniform float u_rotationSpeed;
      uniform float u_colorBalance;
      uniform float u_time;
      varying vec2 v_texCoord;
      
      // Base warp function.
      vec2 warpUV(vec2 uv, float zoom) {
        vec2 offset = uv - 0.5;
        float r = length(offset);
        float factor = mix(1.0, zoom, smoothstep(0.0, 1.0, r));
        return 0.5 + offset * factor;
      }
      
      // Warp function for offset channels with extra distortion.
      vec2 warpChannel(vec2 uv, float zoom, float extraWarp) {
        vec2 offset = uv - 0.5;
        float r = length(offset);
        float factor = mix(1.0, zoom * (1.0 + extraWarp * smoothstep(0.0, 1.0, r)), smoothstep(0.0, 1.0, r));
        return 0.5 + offset * factor;
      }
      
      // Rotation function
      vec2 rotate(vec2 uv, float angle) {
        float s = sin(angle);
        float c = cos(angle);
        mat2 rotMat = mat2(c, -s, s, c);
        return (uv - 0.5) * rotMat + 0.5;
      }
      
      void main(){
        vec2 center = vec2(0.5, 0.5);
        
        // Apply time-based effects if enabled
        float pulseEffect = 1.0;
        if (u_pulseSpeed > 0.0) {
          pulseEffect = 1.0 + 0.2 * sin(u_time * u_pulseSpeed);
        }
        
        float rotationAngle = 0.0;
        if (u_rotationSpeed > 0.0) {
          // Create oscillating rotation that changes direction
          // Using sin to oscillate between -1 and 1, multiplied by PI to get half rotations
          rotationAngle = sin(u_time * u_rotationSpeed * 0.05) * 3.14159;
        }
        
        // Apply rotation if enabled
        vec2 rotatedCoord = rotate(v_texCoord, rotationAngle);
        
        // Base warped UV with pulse effect
        vec2 baseUV = warpUV(rotatedCoord, u_zoom * pulseEffect);
        vec4 baseColor = texture2D(u_image, baseUV);
        
        // Radial vector from center.
        vec2 delta = rotatedCoord - center;
        float r = length(delta);
        vec2 radial = (r < 0.0001) ? vec2(0.0) : normalize(delta);
        
        // Progressive shift amount.
        float shiftAmount = u_colorShift / u_resolution.x * smoothstep(0.0, 1.0, r);
        
        // Apply different multipliers for each channel.
        vec2 redUV = warpChannel(rotatedCoord + radial * shiftAmount * u_redMultiplier, u_zoom * pulseEffect, 0.7);
        vec2 greenUV = warpChannel(rotatedCoord + radial * shiftAmount * u_greenMultiplier, u_zoom * pulseEffect, 0.4);
        vec2 blueUV = warpChannel(rotatedCoord - radial * shiftAmount * u_blueMultiplier, u_zoom * pulseEffect, 1.0);
        
        // Sample and tint each channel.
        vec4 redSample = texture2D(u_image, redUV);
        redSample = vec4(redSample.r, 0.0, 0.0, 1.0);
        
        vec4 greenSample = texture2D(u_image, greenUV);
        greenSample = vec4(0.0, greenSample.g, 0.0, 1.0);
        
        vec4 blueSample = texture2D(u_image, blueUV);
        blueSample = vec4(0.0, 0.0, blueSample.b, 1.0);
        
        // Blend the base with the pure tinted channels.
        vec4 color = baseColor * (1.0 - u_colorBalance) + (redSample + greenSample + blueSample) * u_colorBalance;
        
        // Apply vignette based on distance from center.
        float dist = distance(v_texCoord, center);
        float vig = smoothstep(0.6, 1.0, dist);
        color.rgb *= mix(1.0, 1.0 - u_vignette, vig);
        
        gl_FragColor = color;
      }
    `;
    
    // Glitch shader
    const glitchShaderSource = `
      precision mediump float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_pixelSize;
      uniform float u_scale;
      uniform float u_spacing;
      uniform vec3 u_tintBlackColor;
      uniform vec3 u_tintWhiteColor;
      uniform float u_tintAmount;
      uniform bool u_useGeometricPatterns;
      uniform float u_glowIntensity;
      uniform float u_waveSpeed;
      uniform float u_waveAmplitude;
      uniform float u_waveSize;
      varying vec2 v_texCoord;

      // Random function for noise
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      // Get luminance value
      float getLuma(vec3 color) {
        return dot(color, vec3(0.299, 0.587, 0.114));
      }

      // Gaussian blur function for glow effect
      vec3 applyGlow(vec2 uv, float luma, float intensity) {
        vec3 glow = vec3(0.0);
        float totalWeight = 0.0;
        
        // Adjust blur radius based on glow intensity
        float radius = intensity * 0.02;
        
        // Sample in a 5x5 grid for the blur
        for (int x = -2; x <= 2; x++) {
          for (int y = -2; y <= 2; y++) {
            vec2 offset = vec2(float(x), float(y)) * radius;
            vec2 samplePos = uv + offset;
            
            // Calculate Gaussian weight based on distance
            float weight = exp(-dot(offset, offset) * 4.0);
            
            // Sample the texture and calculate luminance
            vec4 sampleColor = texture2D(u_image, samplePos);
            float sampleLuma = getLuma(sampleColor.rgb);
            
            // Only add bright areas to the glow
            if (sampleLuma > 0.7) {
              // Use pure white for the glow instead of the pixel color
              glow += vec3(1.0) * weight;
              totalWeight += weight;
            }
          }
        }
        
        // Normalize the glow
        if (totalWeight > 0.0) {
          glow /= totalWeight;
        }
        
        return glow;
      }

      // Function to determine if we should draw a pattern at this position
      bool shouldDrawPattern(vec2 pos, float luma) {
        if (!u_useGeometricPatterns) return false;
        
        // Normalize position to 0-1 range within the pixel
        vec2 normPos = fract(pos);
        
        if (luma <= 0.2) {
          // Darkest - empty pattern
          return false;
        } else if (luma <= 0.4) {
          // Dark - 4 dots in corners
          vec2 dotPos = abs(normPos - 0.5) * 2.0;
          return dotPos.x > 0.7 && dotPos.y > 0.7;
        } else if (luma <= 0.6) {
          // Mid - diagonal line
          return abs(normPos.x - normPos.y) < 0.2;
        } else if (luma <= 0.8) {
          // Light - X pattern
          return abs(normPos.x - normPos.y) < 0.15 || abs(normPos.x + normPos.y - 1.0) < 0.15;
        } else {
          // Lightest - empty pattern
          return false;
        }
      }

      void main() {
        // Apply wave distortion
        float waveTime = u_time * u_waveSpeed;
        vec2 waveOffset = vec2(
          sin(v_texCoord.y * u_waveSize + waveTime) * u_waveAmplitude,
          cos(v_texCoord.x * u_waveSize + waveTime) * u_waveAmplitude
        );
        vec2 pos = v_texCoord + waveOffset;
        
        // Apply scaling from center
        vec2 center = vec2(0.5, 0.5);
        pos = (pos - center) / u_scale + center;
        
        // Calculate pixelated coordinates for dithering
        vec2 pixelPos = floor(pos * u_resolution / u_pixelSize) * u_pixelSize / u_resolution;
        vec2 inPixelPos = fract((pos * u_resolution) / u_pixelSize);
        
        // Add spacing between pixels
        float halfSpacing = u_spacing * 0.5;
        vec2 spacedPos = vec2(
          (inPixelPos.x - halfSpacing) / (1.0 - u_spacing),
          (inPixelPos.y - halfSpacing) / (1.0 - u_spacing)
        );
        
        // Sample the original image
        vec4 color = texture2D(u_image, pixelPos);
        float luma = getLuma(color.rgb);
        
        // Add noise variation
        float noise = random(pixelPos + u_time * 0.1) * 0.1;
        luma += noise;
        
        // Determine if we should draw a pattern at this position
        bool isPattern = shouldDrawPattern(pos * u_resolution / u_pixelSize, luma);
        
        // Check if we're in the spacing area
        bool isSpacing = spacedPos.x < 0.0 || spacedPos.x > 1.0 || 
                        spacedPos.y < 0.0 || spacedPos.y > 1.0;
        
        // Calculate the base color based on pattern and spacing
        vec3 baseColor;
        if (isSpacing) {
          baseColor = u_tintBlackColor;
        } else if (isPattern) {
          baseColor = u_tintWhiteColor;
        } else {
          baseColor = u_tintBlackColor;
        }
        
        // Apply cross-pixel glow effect
        vec3 glowColor = applyGlow(pos, luma, u_glowIntensity);
        baseColor = mix(baseColor, glowColor, u_glowIntensity * 0.5);
        
        // Apply tint amount
        vec3 finalColor = mix(color.rgb, baseColor, u_tintAmount);
        
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;
    
    // Lens flare shader
    const lensFlareShaderSource = `
      precision mediump float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_flareIntensity;
      uniform vec2 u_flarePosition;
      uniform float u_rainbowIntensity;
      uniform float u_flareSpeed;
      uniform float u_glareSize;
      uniform float u_rayCount;
      uniform float u_flareScale;
      uniform float u_positionWiggle;
      uniform float u_vignetteIntensity;
      uniform float u_noiseIntensity;
      uniform float u_zoomEffect;
      uniform float u_zoomSpeed;
      varying vec2 v_texCoord;
      
      // Random and noise functions
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      // Improved noise function (Procedural)
      float noise(float t) {
        return random(vec2(t, t * 0.5 + u_time * 0.1));
      }
      
      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        
        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        
        // Smooth interpolation
        vec2 u = f * f * (3.0 - 2.0 * f); // Cubic Hermite curve
        
        // Mix 4 corners
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }
      
      // Helper function for HSL to RGB conversion
      float hue2rgb(float p, float q, float t) {
        if (t < 0.0) t += 1.0;
        if (t > 1.0) t -= 1.0;
        if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
        if (t < 1.0/2.0) return q;
        if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
        return p;
      }
      
      // Color conversion functions
      vec3 rgb2hsl(vec3 color) {
        float maxVal = max(max(color.r, color.g), color.b);
        float minVal = min(min(color.r, color.g), color.b);
        float delta = maxVal - minVal;
        
        vec3 hsl = vec3(0.0, 0.0, (maxVal + minVal) / 2.0);
        
        if (delta > 0.0) {
          hsl.y = (hsl.z < 0.5) ? (delta / (maxVal + minVal)) : (delta / (2.0 - maxVal - minVal));
          
          if (maxVal == color.r) {
            hsl.x = (color.g - color.b) / delta + (color.g < color.b ? 6.0 : 0.0);
          } else if (maxVal == color.g) {
            hsl.x = (color.b - color.r) / delta + 2.0;
          } else {
            hsl.x = (color.r - color.g) / delta + 4.0;
          }
          
          hsl.x /= 6.0;
        }
        
        return hsl;
      }
      
      vec3 hsl2rgb(vec3 hsl) {
        vec3 rgb = vec3(0.0);
        
        if (hsl.y == 0.0) {
          rgb = vec3(hsl.z);
        } else {
          float q = hsl.z < 0.5 ? hsl.z * (1.0 + hsl.y) : hsl.z + hsl.y - hsl.z * hsl.y;
          float p = 2.0 * hsl.z - q;
          
          rgb.r = hue2rgb(p, q, hsl.x + 1.0/3.0);
          rgb.g = hue2rgb(p, q, hsl.x);
          rgb.b = hue2rgb(p, q, hsl.x - 1.0/3.0);
        }
        
        return rgb;
      }
      
      // Function to find the most saturated and bright color in the image
      vec3 findDominantColor(sampler2D tex, vec2 uv, vec2 resolution) {
        vec3 dominantColor = vec3(0.0);
        float maxSaturation = 0.0;
        
        // Sample in a 3x3 grid around the current pixel
        for (int x = -1; x <= 1; x++) {
          for (int y = -1; y <= 1; y++) {
            vec2 offset = vec2(float(x), float(y)) / resolution;
            vec2 samplePos = uv + offset;
            vec4 sampleColor = texture2D(tex, samplePos);
            
            // Convert to HSL to check saturation
            vec3 hsl = rgb2hsl(sampleColor.rgb);
            
            // Update dominant color if this sample is more saturated
            if (hsl.y > maxSaturation) {
              maxSaturation = hsl.y;
              dominantColor = sampleColor.rgb;
            }
          }
        }
        
        return dominantColor;
      }
      
      // Function to apply color filter while maintaining luma
      vec3 applyColorFilter(vec3 color, vec3 filterColor) {
        float luma = dot(color, vec3(0.299, 0.587, 0.114));
        vec3 hsl = rgb2hsl(filterColor);
        hsl.z = luma; // Preserve original luma
        return hsl2rgb(hsl);
      }
      
      // Function to create lens flare effect
      vec3 lensFlare(vec2 uv, vec2 flarePos, float intensity, float scale) {
        vec2 flareDir = uv - flarePos;
        float flareDist = length(flareDir);
        
        // Normalize direction
        flareDir = flareDir / flareDist;
        
        // Calculate angle for rainbow effect
        float angle = atan(flareDir.y, flareDir.x);
        
        // Create rainbow color
        vec3 rainbow = 0.5 + 0.5 * vec3(
          sin(angle + 0.0),
          sin(angle + 2.094),
          sin(angle + 4.189)
        );
        
        // Create rays
        float rays = 0.0;
        const int NUM_RAYS = 48;
        for (int i = 0; i < NUM_RAYS; i++) {
          float rayAngle = float(i) * 6.28318 / float(NUM_RAYS);
          vec2 rayDir = vec2(cos(rayAngle), sin(rayAngle));
          float rayDot = abs(dot(flareDir, rayDir));
          rays += pow(rayDot, 8.0);
        }
        rays = rays / float(NUM_RAYS);
        
        // Create flare
        float flare = 1.0 - smoothstep(0.0, scale, flareDist);
        flare = pow(flare, 4.0);
        
        // Combine effects
        vec3 flareColor = mix(vec3(1.0), rainbow, u_rainbowIntensity);
        float flareValue = flare * rays * intensity;
        
        return flareColor * flareValue;
      }
      
      // Function to apply vignette effect
      vec3 applyVignette(vec3 color, vec2 uv, float intensity) {
        vec2 vignetteUV = (uv - 0.5) * 2.0;
        float vignette = 1.0 - dot(vignetteUV, vignetteUV) * intensity;
        return color * vignette;
      }
      
      // Function to apply noise effect
      vec3 applyNoise(vec3 color, vec2 uv, float time, float intensity) {
        float noiseValue = noise(uv * 10.0 + time) * intensity;
        return color + noiseValue;
      }
      
      void main() {
        // Get the base image color with zoom effect
        vec2 center = vec2(0.5, 0.5);
        
        // Create smooth back-and-forth zoom motion
        float cycleTime = u_time * u_zoomSpeed;
        float t = abs(mod(cycleTime, 2.0) - 1.0); // Smooth ping-pong between 0 and 1
        float zoomFactor = 1.0 + u_zoomEffect * t;
        vec2 zoomedUV = (v_texCoord - center) / zoomFactor + center;
        vec4 baseColor = texture2D(u_image, zoomedUV);
        
        // Find the dominant color in the image
        vec3 dominantColor = findDominantColor(u_image, v_texCoord, u_resolution);
        
        // Apply color filter to the base image while maintaining luma
        vec3 filteredColor = applyColorFilter(baseColor.rgb, dominantColor);
        
        // Apply lens flare effect
        vec2 flarePos = u_flarePosition;
        
        // Add position wiggle
        float wiggleTime = u_time * u_flareSpeed;
        flarePos.x += sin(wiggleTime * 2.0) * u_positionWiggle;
        flarePos.y += cos(wiggleTime * 1.5) * u_positionWiggle;
        
        // Calculate flare effect
        vec3 flareColor = lensFlare(v_texCoord, flarePos, u_flareIntensity, u_flareScale);
        
        // Mix the filtered color with the flare effect
        vec3 finalColor = mix(filteredColor, flareColor, u_flareIntensity * 0.5);
        
        // Apply vignette
        finalColor = applyVignette(finalColor, v_texCoord, u_vignetteIntensity);
        
        // Apply noise
        finalColor = applyNoise(finalColor, v_texCoord, u_time, u_noiseIntensity);
        
        // Output the final color
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;
    
    function renderBackground() {
      if (!backgroundWidget) return;
      
      if (backgroundWidget.effectPreset === "psychedelic" || 
          backgroundWidget.effectPreset === "glitch" || 
          backgroundWidget.effectPreset === "lensFlare") {
        
        // Use WebGL for effects
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Check if we have a texture to use
        if (!backgroundWidget.image || !backgroundWidget.texture) {
          // Draw a placeholder if no image is available
          ctx2d.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
          ctx2d.fillStyle = "#333";
          ctx2d.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
          ctx2d.strokeStyle = "#f00";
          ctx2d.lineWidth = 2;
          ctx2d.strokeRect(2, 2, bgCanvas.width - 4, bgCanvas.height - 4);
          ctx2d.fillStyle = "#fff";
          ctx2d.font = "16px sans-serif";
          ctx2d.textAlign = "center";
          ctx2d.fillText("Upload an image", bgCanvas.width / 2, bgCanvas.height / 2);
          return;
        }
        
        try {
          // Bind the texture
          gl.bindTexture(gl.TEXTURE_2D, backgroundWidget.texture);
          
          // Set the active program based on the effect
          if (backgroundWidget.effectPreset === "psychedelic") {
            gl.useProgram(psychedelicProgram);
            
            // Set attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(psychedelicLocations.a_position);
            gl.vertexAttribPointer(psychedelicLocations.a_position, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(psychedelicLocations.a_texCoord);
            gl.vertexAttribPointer(psychedelicLocations.a_texCoord, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms
            gl.uniform2f(psychedelicLocations.u_resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(psychedelicLocations.u_zoom, psychedelicParams.zoom);
            gl.uniform1f(psychedelicLocations.u_vignette, psychedelicParams.vignette);
            gl.uniform1f(psychedelicLocations.u_colorShift, psychedelicParams.colorShift);
            gl.uniform1f(psychedelicLocations.u_redMultiplier, psychedelicParams.redMultiplier);
            gl.uniform1f(psychedelicLocations.u_greenMultiplier, psychedelicParams.greenMultiplier);
            gl.uniform1f(psychedelicLocations.u_blueMultiplier, psychedelicParams.blueMultiplier);
            gl.uniform1f(psychedelicLocations.u_pulseSpeed, psychedelicParams.pulseSpeed);
            gl.uniform1f(psychedelicLocations.u_rotationSpeed, psychedelicParams.rotationSpeed);
            gl.uniform1f(psychedelicLocations.u_colorBalance, psychedelicParams.colorBalance);
            gl.uniform1f(psychedelicLocations.u_time, performance.now() / 1000);
            
          } else if (backgroundWidget.effectPreset === "glitch") {
            gl.useProgram(glitchProgram);
            
            // Set attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(glitchLocations.a_position);
            gl.vertexAttribPointer(glitchLocations.a_position, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(glitchLocations.a_texCoord);
            gl.vertexAttribPointer(glitchLocations.a_texCoord, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms
            gl.uniform2f(glitchLocations.u_resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(glitchLocations.u_time, performance.now() / 1000);
            gl.uniform1f(glitchLocations.u_pixelSize, glitchParams.pixelSize);
            gl.uniform1f(glitchLocations.u_scale, glitchParams.scale);
            gl.uniform1f(glitchLocations.u_spacing, glitchParams.spacing);
            gl.uniform3fv(glitchLocations.u_tintBlackColor, glitchParams.tintBlackColor);
            gl.uniform3fv(glitchLocations.u_tintWhiteColor, glitchParams.tintWhiteColor);
            gl.uniform1f(glitchLocations.u_tintAmount, glitchParams.tintAmount);
            gl.uniform1i(glitchLocations.u_useGeometricPatterns, glitchParams.useGeometricPatterns);
            gl.uniform1f(glitchLocations.u_glowIntensity, glitchParams.glowIntensity);
            gl.uniform1f(glitchLocations.u_waveSpeed, glitchParams.waveSpeed);
            gl.uniform1f(glitchLocations.u_waveAmplitude, glitchParams.waveAmplitude);
            gl.uniform1f(glitchLocations.u_waveSize, glitchParams.waveSize);
            
          } else if (backgroundWidget.effectPreset === "lensFlare") {
            gl.useProgram(lensFlareProgram);
            
            // Set attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(lensFlareLocations.a_position);
            gl.vertexAttribPointer(lensFlareLocations.a_position, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(lensFlareLocations.a_texCoord);
            gl.vertexAttribPointer(lensFlareLocations.a_texCoord, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms
            gl.uniform2f(lensFlareLocations.u_resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(lensFlareLocations.u_time, performance.now() / 1000);
            gl.uniform1f(lensFlareLocations.u_flareIntensity, lensFlareParams.flareIntensity);
            gl.uniform2fv(lensFlareLocations.u_flarePosition, [lensFlareParams.flarePosX, lensFlareParams.flarePosY]);
            gl.uniform1f(lensFlareLocations.u_rainbowIntensity, lensFlareParams.rainbowIntensity);
            gl.uniform1f(lensFlareLocations.u_flareSpeed, lensFlareParams.flareSpeed);
            gl.uniform1f(lensFlareLocations.u_glareSize, lensFlareParams.glareSize);
            gl.uniform1f(lensFlareLocations.u_rayCount, lensFlareParams.rayCount);
            gl.uniform1f(lensFlareLocations.u_flareScale, lensFlareParams.flareScale);
            gl.uniform1f(lensFlareLocations.u_positionWiggle, lensFlareParams.positionWiggle);
            gl.uniform1f(lensFlareLocations.u_vignetteIntensity, lensFlareParams.vignetteIntensity);
            gl.uniform1f(lensFlareLocations.u_noiseIntensity, lensFlareParams.noiseIntensity);
            gl.uniform1f(lensFlareLocations.u_zoomEffect, lensFlareParams.zoomEffect);
            gl.uniform1f(lensFlareLocations.u_zoomSpeed, lensFlareParams.zoomSpeed);
          }
          
          // Draw the rectangle (6 vertices for 2 triangles)
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          
          // Request next frame for animation
          requestAnimationFrame(renderBackground);
        } catch (error) {
          console.error("Error rendering background:", error);
          // Fallback to 2D rendering if WebGL fails
          ctx2d.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
          ctx2d.drawImage(backgroundWidget.image, 0, 0, bgCanvas.width, bgCanvas.height);
        }
      }
    }
    
    // Start rendering loop
    renderBackground();

    // Update widget controls based on selected widget
    function updateWidgetControls() {
      const widgetControls = document.getElementById('widgetControls');
      const psychedelicControls = document.getElementById('psychedelicControls');
      const glitchControls = document.getElementById('glitchControls');
      const lensFlareControls = document.getElementById('lensFlareControls');
      
      if (!selectedWidget) {
        widgetControls.style.display = 'none';
        return;
      }
      
      widgetControls.style.display = 'block';
      
      // Hide all effect controls first
      psychedelicControls.style.display = 'none';
      glitchControls.style.display = 'none';
      lensFlareControls.style.display = 'none';
      
      // Show controls based on the selected widget's effect preset
      if (selectedWidget.effectPreset === 'psychedelic') {
        psychedelicControls.style.display = 'block';
      } else if (selectedWidget.effectPreset === 'glitch') {
        glitchControls.style.display = 'block';
      } else if (selectedWidget.effectPreset === 'lensFlare') {
        lensFlareControls.style.display = 'block';
      }
    }
    
    // Apply background preset
    function applyBackgroundPreset(preset) {
      if (!backgroundWidget) return;
      
      backgroundWidget.effectPreset = preset;
      selectedWidget = backgroundWidget;
      updateWidgetControls();
      renderBackground();
    }
    
    // Apply background effect
    function applyBackgroundEffect(effect) {
      if (!backgroundWidget) return;
      
      backgroundWidget.effectPreset = effect;
      selectedWidget = backgroundWidget;
      updateWidgetControls();
      renderBackground();
    }
    
    // Remove selected widget
    function removeSelectedWidget() {
      if (!selectedWidget) return;
      
      if (selectedWidget === backgroundWidget) {
        backgroundWidget = null;
      }
      
      selectedWidget = null;
      updateWidgetControls();
      renderBackground();
    }
  </script>
</body>
</html> 